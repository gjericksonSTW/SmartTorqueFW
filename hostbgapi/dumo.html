
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!-- Build version : -->
<style type="text/css">
body{
    font-family:Arial,Helvetica,FreeSans,sans-serif;
    font-size:10pt;
    line-height:1.2;
    color:#717073;
    margin:0;
    padding:0;
}
#main 
{
    position:relative;
    left:15%;
    width:50%;
}
#sidebar 
{
    position:fixed;
    left:0;
    top:0;
    width:15%
    white-space:nowrap;
}
#sidebar ul
{
    list-style-type: none;
    font-size:1.5em;
}
ul
{
    list-style-type: none;
}
.BGSCRIPT_TABLE,.CCODE_TABLE{
    border:1px dashed #717073;
    border-radius:0 0 5px 5px;
    width: 51em;
}
.ENUM_TABLE,.MESSAGE_TABLE,.BGSCRIPT_TABLE,.EVENT_TABLE
{
}

.ENUM_TABLE td:nth-child(1)
{
    color:black;
}
tr:nth-child(even)
{
    background-color:#e2e1dd;
}
.EVENT_TABLE td
{
    padding-left:1em;
    padding-right:1em;
    padding-top:1em;
}
.ENUM_TABLE td
{
    padding-left:1em;
    padding-right:1em;
}
td{
    min-width:10em;
    vertical-align:top;
}
.ENUM_TABLE th
{
    color:black;
}
caption{
    background:#007ac9;
    color:white;
    border-radius:5px 5px 0 0;
    padding:.5em;
    font-weight:bold;
    min-width:50em;
}
header{
    color:black;
}
code{
color:black;
}
.cls header{
    font-size:3em;
    padding-bottom:1em;
}
.msg_type header{
    font-size:2em;
}
.msg_type{
    padding-left:2em;
}
.error_type header{
    font-size:3em;
}


.ERROR_TABLE{
    margin-left:4em;
}


.command header,.event header,.enum header
{
    font-size:1.5em;
}
.command, .event, .enum
{
    padding-top:2em;
    padding-bottom:2em;
    padding-left:2em;
}
table
{
    margin-bottom:1em;
}

@media print 
{
    #main 
    {
        position:relative;
        left:0;
        width:auto;
    }
    #sidebar 
        {        
        visibility:hidden;
    }
    .command, .event, .enum{
        page-break-inside:avoid;
    }
    .cls, .msg_type, .error_type{
        page-break-before:always;
    }
    
}
</style><title>dumo</title>
</head><body><div id="wrap"><div id="main"><div class="cls" id="cls_bt_connection"><header>Connection management for Bluetooth Classic (bt_connection)</header>
        These commands and events are related to Bluetooth Classic connection management and provide the means to open, close and monitor Bluetooth Classic connections.
        <div class="msg_type"><header>bt_connection commands</header><div class="command" id="cmd_bt_connection_get_rssi"><header >bt_connection_get_rssi</header><div><p>Get RSSI value of a connection.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> BR/EDR Connection, LE Connection or RFCOMM handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_get_rssi(connection)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_get_rssi(uint8 connection);<br><br>/* Response id */<br>dumo_rsp_bt_connection_get_rssi_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_get_rssi_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_rssi_value">bt_connection_rssi_value</a></td></tr></table></div></div><div class="command" id="cmd_bt_connection_list"><header >bt_connection_list</header><div><p>This command can be used to list all RFCOMM connections and check their parameters.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_list()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_list();<br><br>/* Response id */<br>dumo_rsp_bt_connection_list_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_list_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_parameters">bt_connection_parameters</a></td></tr><tr><td><a href="#evt_bt_connection_list_complete">bt_connection_list_complete</a></td></tr></table></div></div><div class="command" id="cmd_bt_connection_read_clock"><header >bt_connection_read_clock</header><div><p>
			Read Bluetooth Clock of a connection/piconet.
			<br>For detailed information, see Bluetooth Specification 4.1, vol. 2, part E, section 7.5.6 (Read Clock Command).
			</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection endpoint handle or rfcomm handle. Zero to read local Bluetooth Clock.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_read_clock(connection)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_read_clock(uint8 connection);<br><br>/* Response id */<br>dumo_rsp_bt_connection_read_clock_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_read_clock_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_clock_value">bt_connection_clock_value</a></td></tr></table></div></div><div class="command" id="cmd_bt_connection_set_active"><header >bt_connection_set_active</header><div><p>This command can be used to set the connection state to active.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> Bluetooth connection endpoint handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_set_active(endpoint)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_set_active(uint8 endpoint);<br><br>/* Response id */<br>dumo_rsp_bt_connection_set_active_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_set_active_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_parameters">bt_connection_parameters</a></td></tr></table></div></div><div class="command" id="cmd_bt_connection_set_role"><header >bt_connection_set_role</header><div><p>This command can be used to set the Bluetooth connection local role. Note that this may not be possible if the remote device is the master and does not 
            allow role changes.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> Endpoint handle</td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_bt_connection_role">role</a></td><td> Bluetooth connection local role</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_set_role(endpoint, <a href="#enum_bt_connection_role">role</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_set_role(uint8 endpoint, <a href="#enum_bt_connection_role">uint8 role</a>);<br><br>/* Response id */<br>dumo_rsp_bt_connection_set_role_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_set_role_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_parameters">bt_connection_parameters</a></td></tr></table></div></div><div class="command" id="cmd_bt_connection_set_sniff"><header >bt_connection_set_sniff</header><div><p>This command can be used to set the sniff parameters for a connection. Please see BLUETOOTH SPECIFICATION Version 4.1 [Vol 2] Part E chapter 7.2.2 for more information regarding the use of the related parameters.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> Bluetooth connection endpoint handle</td></tr><tr><td>5-6</td><td> uint16</td><td> max</td><td> Maximum sniff interval.<ul><li>Range: 0x0004 to 0xfffe</li><li>Only even values are valid</li><li>Sniff interval = 0.625ms x max</li><li>Time range 2.5 ms to 40959 ms</li></ul></td></tr><tr><td>7-8</td><td> uint16</td><td> min</td><td> Minimum sniff interval.<ul><li>Range: 0x0002 to 0xfffe</li><li>Only even values are valid</li><li>Sniff interval = 0.625ms x min</li><li>Time range 1.25 ms to 40959 ms</li></ul></td></tr><tr><td>9-10</td><td> uint16</td><td> attempt</td><td> Number of baseband receive slots for sniff attempt.<ul><li>Range: 0x0001 to 0x7fff</li><li>Time range 0.625 ms to 40959 ms</li></ul></td></tr><tr><td>11-12</td><td> uint16</td><td> timeout</td><td> Number of baseband receive slots for sniff timeout.<ul><li>Range: 0x0000 to 0x7fff</li><li>Time range 0.0 ms to 40959 ms</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_set_sniff(endpoint, max, min, attempt, timeout)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_set_sniff(uint8 endpoint, uint16 max, uint16 min, uint16 attempt, uint16 timeout);<br><br>/* Response id */<br>dumo_rsp_bt_connection_set_sniff_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_set_sniff_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_parameters">bt_connection_parameters</a></td></tr></table></div></div><div class="command" id="cmd_bt_connection_set_supervision_timeout"><header >bt_connection_set_supervision_timeout</header><div><p>This command can be used to set the connection supervision timeout.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> Bluetooth connection endpoint handle</td></tr><tr><td>5-6</td><td> uint16</td><td> supervisiontimeout</td><td> 
                        Supervision timeout defines how long, in multiples of 0.625 ms, the connection can be without any activity before being disconnected. Note that this command has no effect
                        if the local device is not the Master of the connection. Range: 0x0001 - 0xffff. Default value: 0x7D00 (20 seconds)
                        </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_connection_set_supervision_timeout(endpoint, supervisiontimeout)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_connection_set_supervision_timeout(uint8 endpoint, uint16 supervisiontimeout);<br><br>/* Response id */<br>dumo_rsp_bt_connection_set_supervision_timeout_id<br><br>/* Response structure */<br>struct dumo_msg_bt_connection_set_supervision_timeout_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_connection events</header><div class="event" id="evt_bt_connection_opened"><header >bt_connection_opened</header><div><p>This event indicates that a new connection was opened.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth address of the remote device in little endian formats</td></tr><tr><td>10</td><td> uint8</td><td> master</td><td> Bluetooth role of the local device. Values: <ul><li><b>0: </b>Slave</li><li><b>1: </b>Master</li></ul></td></tr><tr><td>11</td><td> uint8</td><td> connection</td><td> Bluetooth connection handle</td></tr><tr><td>12</td><td> uint8</td><td> bonding</td><td> Bonding handle of the remote device<ul><li><b>0xff: </b>No bonding</li><li><b>Other: </b>Bonding handle</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_connection_opened(address, master, connection, bonding)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_connection_opened_id<br><br>/* event structure*/<br>struct dumo_msg_bt_connection_opened_evt_t<br>{<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;uint8 master,<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint8 bonding<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_connection_closed"><header >bt_connection_closed</header><div><p>This event indicates that a connection was closed.
			<p><b>Note:</b> This event corresponds to the Bluetooth connection (not the endpoint) between two devices closing. Once all open endpoints have closed, either side may close the connection. Thus the reason parameter may be either remote_user_terminated or connection_terminated_by_local_host independent of which side closed the last endpoint.
			</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> reason</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> connection</td><td> Bluetooth connection handle</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_connection_closed(reason, connection)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_connection_closed_id<br><br>/* event structure*/<br>struct dumo_msg_bt_connection_closed_evt_t<br>{<br>&nbsp;&nbsp;uint16 reason,<br>&nbsp;&nbsp;uint8 connection<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_connection_parameters"><header >bt_connection_parameters</header><div><p>This event indicates the details of a single RFCOMM connection. This event can be triggered when needed with <a href="#cmd_bt_connection_list">
            bt_connection_list</a>.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x15 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> RFCOMM connection endpoint handle</td></tr><tr><td>5-8</td><td> uint32</td><td> block_size</td><td> Size of a single packet over RFCOMM</td></tr><tr><td>9</td><td> uint8</td><td> msc</td><td> Bit mask for MSC at the local device</td></tr><tr><td>10-15</td><td> bd_addr</td><td> address</td><td> Bluetooth address of the remote device in little endian format</td></tr><tr><td>16</td><td> uint8</td><td> <a href="#enum_bt_connection_direction">direction</a></td><td> Direction of the connection</td></tr><tr><td>17</td><td> uint8</td><td> <a href="#enum_bt_connection_powermode">powermode</a></td><td> Power mode of the connection</td></tr><tr><td>18</td><td> uint8</td><td> <a href="#enum_bt_connection_role">role</a></td><td> Role in the connection</td></tr><tr><td>19</td><td> uint8</td><td> <a href="#enum_bt_connection_encryption">encryption</a></td><td> </td></tr><tr><td>20-23</td><td> uint32</td><td> input_buffer</td><td> Amount of data in the RFCOMM receive buffer</td></tr><tr><td>24</td><td> uint8</td><td> port</td><td> 
                RFCOMM port that was connected</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_connection_parameters(endpoint, block_size, msc, address, direction, powermode, role, encryption, input_buffer, port)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_connection_parameters_id<br><br>/* event structure*/<br>struct dumo_msg_bt_connection_parameters_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;uint32 block_size,<br>&nbsp;&nbsp;uint8 msc,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;<a href="#enum_bt_connection_direction">uint8 direction</a>,<br>&nbsp;&nbsp;<a href="#enum_bt_connection_powermode">uint8 powermode</a>,<br>&nbsp;&nbsp;<a href="#enum_bt_connection_role">uint8 role</a>,<br>&nbsp;&nbsp;<a href="#enum_bt_connection_encryption">uint8 encryption</a>,<br>&nbsp;&nbsp;uint32 input_buffer,<br>&nbsp;&nbsp;uint8 port<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_connection_list_complete"><header >bt_connection_list_complete</header><div><p>This event indicates that all connections have been listed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_connection_list_complete()</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_connection_list_complete_id<br><br>/* event structure*/<br>struct dumo_msg_bt_connection_list_complete_evt_t<br>{<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_connection_rssi_value"><header >bt_connection_rssi_value</header><div><p>RSSI value of a connection.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection  handle. NOTE: this is allways connetion handle regardless whether RSSI was requested by RFCOMM or connection handle</td></tr><tr><td>5</td><td> int8</td><td> rssi</td><td> 
                    For BR/EDR:<br>
                    Received signal strength in dB relative to 'Golden Receive Power Range' which is from -40dBm to -60dBm. 
                    Negative values indicate we are below minimum of the range and positive values indicate that we are above the maximum of the range
                    <br>For LE:<br>
                    Absolute power level in dBm to +-6dB accuracy. If the RSSI cannot be read, the RSSI metric shall be set to 127. 
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_connection_rssi_value(connection, rssi)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_connection_rssi_value_id<br><br>/* event structure*/<br>struct dumo_msg_bt_connection_rssi_value_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;int8 rssi<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_connection_clock_value"><header >bt_connection_clock_value</header><div><p>Bluetooth Clock of a connection/piconet.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x07 </td><td>class</td><td>Message class:Connection management for Bluetooth Classic</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> 
					Connection endpoint handle or zero when reading local clock. 
					NOTE: this is always a connection handle regardless whether clock was requested by RFCOMM or connection handle.
					</td></tr><tr><td>5-8</td><td> uint32</td><td> clock</td><td> 
					Bluetooth Clock of the device requested.
					</td></tr><tr><td>9-10</td><td> uint16</td><td> accuracy</td><td> 
					Maximum Bluetooth Clock error in +- 0.3125 ms units. 0xFFFF means unknown.
					</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_connection_clock_value(connection, clock, accuracy)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_connection_clock_value_id<br><br>/* event structure*/<br>struct dumo_msg_bt_connection_clock_value_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint32 clock,<br>&nbsp;&nbsp;uint16 accuracy<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_connection enumerations</header><div class="enum" id="enum_bt_connection_direction"><header>bt_connection_direction</header><div><p>These values indicate the direction of the connection.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_connection_outgoing</td><td>Outgoing</td></tr><tr><td>1</td><td>bt_connection_incoming</td><td>Incoming</td></tr></table></div></div><div class="enum" id="enum_bt_connection_powermode"><header>bt_connection_powermode</header><div><p>These values indicate the power mode of a connection.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_connection_active</td><td>Active</td></tr><tr><td>1</td><td>bt_connection_hold</td><td>Reserved</td></tr><tr><td>2</td><td>bt_connection_sniff</td><td>Sniff</td></tr><tr><td>3</td><td>bt_connection_park</td><td>Reserved</td></tr></table></div></div><div class="enum" id="enum_bt_connection_role"><header>bt_connection_role</header><div><p>These values indicate the connection role of the local device.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_connection_master</td><td>Master</td></tr><tr><td>1</td><td>bt_connection_slave</td><td>Slave</td></tr></table></div></div><div class="enum" id="enum_bt_connection_encryption"><header>bt_connection_encryption</header><div><p>These values indicate the encryption status of the connection.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_connection_plain</td><td>Unencrypted</td></tr><tr><td>1</td><td>bt_connection_encrypted</td><td>Encrypted</td></tr></table></div></div></div></div><div class="cls" id="cls_bt_gap"><header>Generic Access Profile, Bluetooth Classic (bt_gap)</header>These commands and events are related to Generic Access Profile, Bluetooth Classic.<div class="msg_type"><header>bt_gap commands</header><div class="command" id="cmd_bt_gap_cancel_discovery"><header >bt_gap_cancel_discovery</header><div><p>
            This command can be used to cancel the ongoing Bluetooth Classic device discovery (inquiry) procedure.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_cancel_discovery()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_cancel_discovery();<br><br>/* Response id */<br>dumo_rsp_bt_gap_cancel_discovery_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_cancel_discovery_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_gap_discovery_complete">bt_gap_discovery_complete</a></td></tr></table></div></div><div class="command" id="cmd_bt_gap_discover"><header >bt_gap_discover</header><div><p>
            This command can be used to discover other Bluetooth Classic devices with Bluetooth Classic inquiry.
            <br>Command <a href="#cmd_bt_gap_set_discovery_mode">set_discovery_mode</a> can be used to select how much information is delivered in discovery results
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> timeout</td><td> 
                    The maximum amount of time (in units of 1.28 seconds) before the inquiry process is halted. Range: 1 to 48.
                    <ul><li>Example: Value 5 corresponds to 5 x 1.28 seconds = 6.4 seconds.</li></ul>
                    </td></tr><tr><td>5-8</td><td> int32</td><td> <a href="#enum_bt_gap_discover_mode">lap</a></td><td> 
                    Flag which selects whether to seek only devices that are in general discovery mode or in limited discovery mode.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_discover(timeout, <a href="#enum_bt_gap_discover_mode">lap</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_discover(uint8 timeout, <a href="#enum_bt_gap_discover_mode">int32 lap</a>);<br><br>/* Response id */<br>dumo_rsp_bt_gap_discover_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_discover_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_gap_discovery_result">bt_gap_discovery_result</a></td></tr><tr><td><a href="#evt_bt_gap_discovery_complete">bt_gap_discovery_complete</a></td></tr></table></div></div><div class="command" id="cmd_bt_gap_get_mode"><header >bt_gap_get_mode</header><div><p>This command can be used to read the device's Bluetooth Classic visibility and connectability settings.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> connectable</td><td> Informs whether the device accepts incoming connections or not. Values: <ul><li><b>0: </b>Not connectable</li><li><b>1: </b>Connectable</li></ul></td></tr><tr><td>7</td><td> uint8</td><td> discoverable</td><td> Informs whether the device is visible for inquiry. Values: <ul><li><b>0: </b>Not discoverable</li><li><b>1: </b>Discoverable</li></ul></td></tr><tr><td>8</td><td> uint8</td><td> <a href="#enum_bt_gap_discover_mode">limited</a></td><td> Informs whether the device is visible only in limited mode inquiry or in general mode inquiry</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_get_mode()(result, connectable, discoverable, <a href="#enum_bt_gap_discover_mode">limited</a>)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_get_mode();<br><br>/* Response id */<br>dumo_rsp_bt_gap_get_mode_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_get_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 connectable,<br>&nbsp;&nbsp;uint8 discoverable,<br>&nbsp;&nbsp;<a href="#enum_bt_gap_discover_mode">uint8 limited</a><br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_get_remote_name"><header >bt_gap_get_remote_name</header><div><p>This command can be used to read the name of the remote Bluetooth Classic device.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth address of the remote Bluetooth Classic device in little endian format</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_get_remote_name(address)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_get_remote_name(bd_addr *address);<br><br>/* Response id */<br>dumo_rsp_bt_gap_get_remote_name_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_get_remote_name_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_gap_remote_name">bt_gap_remote_name</a></td></tr></table></div></div><div class="command" id="cmd_bt_gap_open"><header >bt_gap_open</header><div><p>This command can be used to open a Bluetooth Classic connection to a remote device. 
            The connection can be closed with the <a href="#cmd_endpoint_close">
            endpoint_close</a> command.<br><br> 
            Command can be used for example when there is an need to bond the devices without 
            opening a RFCOMM connection.
            After connection
            has been opened bonding can be done with the <a href="#cmd_sm_increase_security">
            sm_increase_security</a> command.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth address</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> connection</td><td> Unique connection handle</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_open(address)(result, connection)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_open(bd_addr *address);<br><br>/* Response id */<br>dumo_rsp_bt_gap_open_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_open_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 connection<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_connection_opened">bt_connection_opened</a></td><td></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_auto_sniff"><header >bt_gap_set_auto_sniff</header><div><p>Set automatic sniff parameters for all connections. Please see the BLUETOOTH SPECIFICATION Version 4.1 [Vol 2] Part E chapter 7.2.2 for more information regarding the use of the related parameters.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x0b </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> mode</td><td> 
                    Defines automatic sniff mode. Values: <ul><li><b>0: </b>Do not use automatic sniff</li><li><b>1: </b>Set connection active whenever data is transmitted</li><li>
                    <b>2: </b>Set connection to sniff when idle time is exceeded</li><li><b>3: </b>Set both active and sniff automatically</li></ul>
                    </td></tr><tr><td>5-6</td><td> uint16</td><td> idle</td><td> The time (in seconds) a link has to be idle before it will be set to sniff mode. Range: 1 - 250</td></tr><tr><td>7-8</td><td> uint16</td><td> max</td><td> Maximum sniff interval.<ul><li>Range: 0x0004 - 0xfffe</li><li>Only even values are valid</li><li>Sniff interval = 0.625ms x max</li><li>Time range 2.5 ms to 40959 ms
                    </li></ul>Recommended default: 0x00a0 - 0x0640 (100 ms - 1000 ms)</td></tr><tr><td>9-10</td><td> uint16</td><td> min</td><td> Minimum sniff interval.<ul><li>
                    Range: 0x0002 - 0xfffe</li><li>Only even values are valid</li><li>Sniff interval = 0.625ms x min</li><li>Time range 1.25 ms - 40959 ms</li></ul>Recommended default: 0x20</td></tr><tr><td>11-12</td><td> uint16</td><td> attempt</td><td> Number of baseband receive slots for sniff attempt.<ul><li>Range: 0x0001-0x7fff</li><li>Time range 0.625 ms to 40959 ms</li></ul>Recommended default: 1</td></tr><tr><td>13-14</td><td> uint16</td><td> timeout</td><td> Number of baseband receive slots for sniff timeout.<ul><li>Range: 0x0000-0x7fff</li><li>Time range 0.0 ms to 40959 ms</li></ul>Recommended default: 8</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_auto_sniff(mode, idle, max, min, attempt, timeout)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_auto_sniff(uint8 mode, uint16 idle, uint16 max, uint16 min, uint16 attempt, uint16 timeout);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_auto_sniff_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_auto_sniff_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_discovery_mode"><header >bt_gap_set_discovery_mode</header><div><p>
            This command can be used to set the discovery mode. This determines the information given in <a href="#evt_bt_gap_discovery_result">discovery_result</a> events.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> mode</td><td> 
                     Format on discovery results:<br></br>
                     0: Standard short format.<br></br>
                     1: With RSSI result.<br></br>
                     2: Extended format.<br></br>
                     Valuea at startup: 1
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_discovery_mode(mode)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_discovery_mode(uint8 mode);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_discovery_mode_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_discovery_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_host_channel_classification"><header >bt_gap_set_host_channel_classification</header><div><p>This command configures Bluetooth Classic channel classifications.. If successful, a <a href="#evt_bt_gap_host_channel_classification_complete">bt_gap_host_channel_classification_complete</a> event will follow when the controller has completed the configuration.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> channel_map</td><td> Channel bitmap for 79 channels. Mark known bad channels with a zero bit, other channels with a one bit. The parameter must be given as exactly 10 bytes; the highest bit is ignored. </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_host_channel_classification(channel_map_len, channel_map_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_host_channel_classification(uint8 channel_map_len, const uint8 *channel_map_data);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_host_channel_classification_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_host_channel_classification_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_max_power"><header >bt_gap_set_max_power</header><div><p>This command can be used to set the maximum TX power for Bluetooth Classic.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> int8</td><td> max_power</td><td> Maximum radio TX power. <ul><li>Value range: -20 - 12.</li><li>Default value: 12</li><li>Note that the power measured at the antenna is slightly (1-3 dB) lower than this value.</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_max_power(max_power)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_max_power(int8 max_power);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_max_power_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_max_power_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_mode"><header >bt_gap_set_mode</header><div><p>This command can be used to set Bluetooth Classic visibility and connectability.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connectable</td><td> Determines whether the device accepts incoming connections or not. Values: <ul><li><b>0: </b>Not connectable</li><li><b>1: </b>Connectable</li></ul>Default value: 0</td></tr><tr><td>5</td><td> uint8</td><td> discoverable</td><td> Determines whether the device is visible in Bluetooth Classic inquiry. Values:<ul><li><b>0: </b>Not discoverable</li><li><b>1: </b>Discoverable</li></ul>Default value: 0</td></tr><tr><td>6</td><td> uint8</td><td> <a href="#enum_bt_gap_discover_mode">limited</a></td><td> Determines whether the device is visible in limited mode inquiry or in general mode inquiry. Default value: general mode</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_mode(connectable, discoverable, <a href="#enum_bt_gap_discover_mode">limited</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_mode(uint8 connectable, uint8 discoverable, <a href="#enum_bt_gap_discover_mode">uint8 limited</a>);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_mode_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_parameters"><header >bt_gap_set_parameters</header><div><p>This command can be used to set the default page timeout and scan mode.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> pagetimeout</td><td> 
                        Page timeout defines how long the connection establishment can take before an error occurs, in multiples of 0.625 milliseconds. Range: 0x0001 - 0xffff. Default value: 0x2000 (5.12 seconds)
                        </td></tr><tr><td>6-7</td><td> uint16</td><td> scan_interval</td><td> Page scan interval in multiples of 0.625ms, values from 0x12 to 0x1000, only even numbers are allowed, see BT Core spec Vol. 2 part D chapter 7.3. Default value: 0x800</td></tr><tr><td>8-9</td><td> uint16</td><td> scan_window</td><td> Page scan window in multiples of 0.625ms, values from 0x11 to 0x1000, must be less than or equal to page scan interval. See BT Core spec Vol. 2 part D chapter 7.3. Default value: 0x12</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_parameters(pagetimeout, scan_interval, scan_window)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_parameters(uint16 pagetimeout, uint16 scan_interval, uint16 scan_window);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_parameters_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_parameters_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_gap_set_policy"><header >bt_gap_set_policy</header><div><p>This command can be used to set default policies for connections. For more information on the use of policies please see BLUETOOTH SPECIFICATION Version 4.1 [Vol 2] Part E chapter 7.2.10.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> allow_role_change</td><td> Defines if the the local device accepts role change requests or not. Values: <ul><li><b>0: </b>Do not allow role change</li><li><b>1: </b>Allow role change</li></ul>Default value: 0</td></tr><tr><td>5</td><td> uint8</td><td> allow_sniff</td><td> This flag defines whether sniff mode is allowed or not. Values: <ul><li><b>0: </b>Do not allow sniff mode</li><li><b>1: </b>Allow sniff mode</li></ul>Default value: 0</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_gap_set_policy(allow_role_change, allow_sniff)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_gap_set_policy(uint8 allow_role_change, uint8 allow_sniff);<br><br>/* Response id */<br>dumo_rsp_bt_gap_set_policy_id<br><br>/* Response structure */<br>struct dumo_msg_bt_gap_set_policy_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_gap events</header><div class="event" id="evt_bt_gap_discovery_result"><header >bt_gap_discovery_result</header><div><p>This event returns the discovery result for a single remote device. The name parameter is present only when using extended discovery mode. The RSSI value is valid only when using RSSI or extended discovery (inquiry) mode. The discovery mode is set by <a href="#cmd_bt_gap_set_discovery_mode">set_discovery_mode</a> command.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x0e </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> bd_addr</td><td> Bluetooth address of the discovered Bluetooth Classic device in little endian format</td></tr><tr><td>10</td><td> uint8</td><td> page_scan_repetition_mode</td><td> Remote devices page scan repetition mode</td></tr><tr><td>11-14</td><td> uint32</td><td> class_of_device</td><td> Class of Device for the device</td></tr><tr><td>15</td><td> int8</td><td> rssi</td><td> RSSI value of the connection. <ul><li>Range: -127 to +20</li><li>Units: dBm</li></ul></td></tr><tr><td>16</td><td> uint8</td><td> bonding</td><td> Remote device's bonding handle. Values: <ul><li><b>0xff: </b>Device is not bonded</li><li><b>Others: </b>Bonding handle</li></ul></td></tr><tr><td>17</td><td> uint8array</td><td> name</td><td> Remote device's Bluetooth Classic friendly name parsed from the Extended Inquiry Response (EIR) data</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_gap_discovery_result(bd_addr, page_scan_repetition_mode, class_of_device, rssi, bonding, name_len, name_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_gap_discovery_result_id<br><br>/* event structure*/<br>struct dumo_msg_bt_gap_discovery_result_evt_t<br>{<br>&nbsp;&nbsp;bd_addr bd_addr,<br>&nbsp;&nbsp;uint8 page_scan_repetition_mode,<br>&nbsp;&nbsp;uint32 class_of_device,<br>&nbsp;&nbsp;int8 rssi,<br>&nbsp;&nbsp;uint8 bonding,<br>&nbsp;&nbsp;uint8array name<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_gap_discovery_complete"><header >bt_gap_discovery_complete</header><div><p>This event indicates that discovery has been completed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> status</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_gap_discovery_complete(status)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_gap_discovery_complete_id<br><br>/* event structure*/<br>struct dumo_msg_bt_gap_discovery_complete_evt_t<br>{<br>&nbsp;&nbsp;uint16 status<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_gap_remote_name"><header >bt_gap_remote_name</header><div><p>This event indicates a reply to a remote name request.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> status</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-11</td><td> bd_addr</td><td> address</td><td> Bluetooth address of the remote Bluetooth Classic device in little endian format</td></tr><tr><td>12</td><td> uint8array</td><td> remote_name</td><td> Name of the remote Bluetooth Classic device</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_gap_remote_name(status, address, remote_name_len, remote_name_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_gap_remote_name_id<br><br>/* event structure*/<br>struct dumo_msg_bt_gap_remote_name_evt_t<br>{<br>&nbsp;&nbsp;uint16 status,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;uint8array remote_name<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_gap_host_channel_classification_complete"><header >bt_gap_host_channel_classification_complete</header><div><p>This event indicates host channel classification request is completed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x02 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Classic</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> status</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_gap_host_channel_classification_complete(status)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_gap_host_channel_classification_complete_id<br><br>/* event structure*/<br>struct dumo_msg_bt_gap_host_channel_classification_complete_evt_t<br>{<br>&nbsp;&nbsp;uint16 status<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_gap enumerations</header><div class="enum" id="enum_bt_gap_discover_mode"><header>bt_gap_discover_mode</header><div><p>These values define the GAP Discoverable mode of the module.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_gap_discover_generic</td><td>Discover devices which are in general discoverable mode.</td></tr><tr><td>1</td><td>bt_gap_discover_limited</td><td>Discover only devices which are in limited discoverable mode.</td></tr></table></div></div></div></div><div class="cls" id="cls_bt_hid"><header>HID (bt_hid)</header>HID connections<br>
        Please note that HID commands are available only in images compiled with HID sdk<div class="msg_type"><header>bt_hid commands</header><div class="command" id="cmd_bt_hid_get_report_response"><header >bt_hid_get_report_response</header><div><p>This command is used to respond to evt_bt_hid_get_report requests. The parameters endpoint, parameters_used, report_type, and report_id should match those received in the request. The report_data should contain the current instantaneous state of the fields specified in the request.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the request.
                    </td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_bt_hid_get_report_params">parameters_used</a></td><td> </td></tr><tr><td>6</td><td> uint8</td><td> <a href="#enum_bt_hid_report_type">report_type</a></td><td> </td></tr><tr><td>7</td><td> uint8</td><td> report_id</td><td> ID of the report requested. Must match both report_type and ID, as the same ID can be used for different report types.</td></tr><tr><td>8</td><td> uint8array</td><td> report_data</td><td> The payload of the Report requested. Note that if the Report is larger than the max_bytes specified in the request, the report data must be truncated to max_bytes, if no report ID was requested; or max_bytes - 1 if an ID was requested.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_get_report_response(endpoint, <a href="#enum_bt_hid_get_report_params">parameters_used</a>, <a href="#enum_bt_hid_report_type">report_type</a>, report_id, report_data_len, report_data_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_get_report_response(uint8 endpoint, <a href="#enum_bt_hid_get_report_params">uint8 parameters_used</a>, <a href="#enum_bt_hid_report_type">uint8 report_type</a>, uint8 report_id, uint8 report_data_len, const uint8 *report_data_data);<br><br>/* Response id */<br>dumo_rsp_bt_hid_get_report_response_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_get_report_response_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_hid_get_set_report_reject"><header >bt_hid_get_set_report_reject</header><div><p>This command is used to reject an evt_bt_hid_get_report request for an invalid Report.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the request.
                    </td></tr><tr><td>5</td><td> uint8</td><td> reason</td><td> 
                        Reason for rejecting. 0 = invalid Report ID, 1 = invalid Report Type or size mismatch.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_get_set_report_reject(endpoint, reason)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_get_set_report_reject(uint8 endpoint, uint8 reason);<br><br>/* Response id */<br>dumo_rsp_bt_hid_get_set_report_reject_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_get_set_report_reject_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_hid_open"><header >bt_hid_open</header><div><p>
            Open HID connection to remote HID Host. Note that the HID Host must have initiated a previous connection and stored our HID SDP entry, and our SDP entry must indicate support for HID Device -initiated connections; otherwise the HID Host will reject our connection attempt.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> 
                Bluetooth device address of the remote device in little endian format
                </td></tr><tr><td>10</td><td> uint8</td><td> streaming_destination</td><td> 
                    For future use. Must be set to 0. 
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> Unsigned 8-bit integer</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_open(address, streaming_destination)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_open(bd_addr *address, uint8 streaming_destination);<br><br>/* Response id */<br>dumo_rsp_bt_hid_open_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_open_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_hid_opened">bt_hid_opened</a></td></tr><tr><td><a href="#evt_bt_hid_failed">bt_hid_failed</a></td></tr><tr><td><a href="#evt_bt_hid_output_report">bt_hid_output_report</a></td></tr></table></div></div><div class="command" id="cmd_bt_hid_send_input_report"><header >bt_hid_send_input_report</header><div><p>
                 This command can be used to send HID Input Reports to the HID Host.
             </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                         Endpoint handle of the HID connection
                     </td></tr><tr><td>5</td><td> uint8</td><td> report_id</td><td> 
                         Report ID, defined in the HID Descriptor
                     </td></tr><tr><td>6</td><td> uint8array</td><td> report_data</td><td> 
                         The data payload of the Input Report (prefixed with length byte)
                     </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_send_input_report(endpoint, report_id, report_data_len, report_data_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_send_input_report(uint8 endpoint, uint8 report_id, uint8 report_data_len, const uint8 *report_data_data);<br><br>/* Response id */<br>dumo_rsp_bt_hid_send_input_report_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_send_input_report_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_hid_set_report_response"><header >bt_hid_set_report_response</header><div><p>This command is used to acknowledge an evt_bt_hid_set_report request. If the parameters are invalid, use cmd_bt_hid_get_set_report_reject to reject it.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the request.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_set_report_response(endpoint)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_set_report_response(uint8 endpoint);<br><br>/* Response id */<br>dumo_rsp_bt_hid_set_report_response_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_set_report_response_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_hid_start_server"><header >bt_hid_start_server</header><div><p>
            This command can be used to start accepting HID connections.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> sdp_id</td><td> ID of the SDP entry defined in project configuration file.</td></tr><tr><td>5</td><td> uint8</td><td> streaming_destination</td><td> 
                        For future use. Must be set to 0.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_start_server(sdp_id, streaming_destination)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_start_server(uint8 sdp_id, uint8 streaming_destination);<br><br>/* Response id */<br>dumo_rsp_bt_hid_start_server_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_start_server_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_hid_opened">bt_hid_opened</a></td></tr><tr><td><a href="#evt_bt_hid_failed">bt_hid_failed</a></td></tr><tr><td><a href="#evt_bt_hid_output_report">bt_hid_output_report</a></td></tr></table></div></div><div class="command" id="cmd_bt_hid_stop_server"><header >bt_hid_stop_server</header><div><p>
            This command can be used to stop an HID server.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> sdp_id</td><td> ID of the SDP entry defined in the project configuration file.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_stop_server(sdp_id)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_stop_server(uint8 sdp_id);<br><br>/* Response id */<br>dumo_rsp_bt_hid_stop_server_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_stop_server_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_hid_virtual_cable_unplug"><header >bt_hid_virtual_cable_unplug</header><div><p>
                 This command can be used to disassociate the device from the HID Host. Bonding information will be deleted and 
                 the connection disconnected automatically.
             </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                         Endpoint handle of the HID connection
                     </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_hid_virtual_cable_unplug(endpoint)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_hid_virtual_cable_unplug(uint8 endpoint);<br><br>/* Response id */<br>dumo_rsp_bt_hid_virtual_cable_unplug_id<br><br>/* Response structure */<br>struct dumo_msg_bt_hid_virtual_cable_unplug_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_hid events</header><div class="event" id="evt_bt_hid_opened"><header >bt_hid_opened</header><div><p>This event indicates the establishment of an HID connection.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                   Endpoint ID assigned for the HID connection 
                    </td></tr><tr><td>5-10</td><td> bd_addr</td><td> address</td><td> 
                    Bluetooth device address of the remote device in little endian format.
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_hid_opened(endpoint, address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_hid_opened_id<br><br>/* event structure*/<br>struct dumo_msg_bt_hid_opened_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_hid_failed"><header >bt_hid_failed</header><div><p>This event indicates the establishment of an HID connection failed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                   Endpoint ID assigned for the HID connection 
                    </td></tr><tr><td>5-10</td><td> bd_addr</td><td> address</td><td> 
                    Bluetooth device address of the remote device in little endian format.
                    </td></tr><tr><td>11-12</td><td> uint16</td><td> reason</td><td> Reason for failure.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_hid_failed(endpoint, address, reason)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_hid_failed_id<br><br>/* event structure*/<br>struct dumo_msg_bt_hid_failed_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;uint16 reason<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_hid_output_report"><header >bt_hid_output_report</header><div><p>This event indicates an HID Output Report was received from the HID Host.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the report.
                    </td></tr><tr><td>5</td><td> uint8</td><td> report_id</td><td> 
                        Report ID defined in the HID Descriptor.
                    </td></tr><tr><td>6</td><td> uint8array</td><td> report_data</td><td> 
                        Payload of the HID Output Report (prefixed by length byte).
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_hid_output_report(endpoint, report_id, report_data_len, report_data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_hid_output_report_id<br><br>/* event structure*/<br>struct dumo_msg_bt_hid_output_report_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;uint8 report_id,<br>&nbsp;&nbsp;uint8array report_data<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_hid_state_changed"><header >bt_hid_state_changed</header><div><p>This event indicates the HID Host has notified the Device about a state change. No response is required.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the notification.
                    </td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_bt_hid_state">state</a></td><td> </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_hid_state_changed(endpoint, state)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_hid_state_changed_id<br><br>/* event structure*/<br>struct dumo_msg_bt_hid_state_changed_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;<a href="#enum_bt_hid_state">uint8 state</a><br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_hid_get_report"><header >bt_hid_get_report</header><div><p>This event indicates the HID Host has requested the current state of a report. This is usually done to determine the initial state of the Device. A response must be sent with cmd_bt_hid_get_report_response. The parameter parameters_used defines which of the parameters were used by the Host to specify the report. The response should be sent with the same parameters_used value.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the notification.
                    </td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_bt_hid_get_report_params">parameters_used</a></td><td> </td></tr><tr><td>6</td><td> uint8</td><td> <a href="#enum_bt_hid_report_type">report_type</a></td><td> </td></tr><tr><td>7</td><td> uint8</td><td> report_id</td><td> ID of the report requested. Must match both report_type and ID, as the same ID can be used for different report types.</td></tr><tr><td>8-9</td><td> uint16</td><td> max_bytes</td><td> Maximum number of bytes to send, if the report size exceeds the current MTU; the remaining bytes are discarded and not sent in another packet. If a Report ID is sent, it takes up one byte.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_hid_get_report(endpoint, parameters_used, report_type, report_id, max_bytes)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_hid_get_report_id<br><br>/* event structure*/<br>struct dumo_msg_bt_hid_get_report_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;<a href="#enum_bt_hid_get_report_params">uint8 parameters_used</a>,<br>&nbsp;&nbsp;<a href="#enum_bt_hid_report_type">uint8 report_type</a>,<br>&nbsp;&nbsp;uint8 report_id,<br>&nbsp;&nbsp;uint16 max_bytes<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_hid_set_report"><header >bt_hid_set_report</header><div><p>This event indicates an HID report was received from the HID Host.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x13 </td><td>class</td><td>Message class:HID</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                        Endpoint handle of the HID Host that sent the report.
                    </td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_bt_hid_report_type">report_type</a></td><td> </td></tr><tr><td>6</td><td> uint8</td><td> report_id</td><td> 
                        Report ID defined in the HID Descriptor.
                    </td></tr><tr><td>7</td><td> uint8array</td><td> report_data</td><td> 
                        Payload of the HID Report (prefixed by length byte).
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_hid_set_report(endpoint, report_type, report_id, report_data_len, report_data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_hid_set_report_id<br><br>/* event structure*/<br>struct dumo_msg_bt_hid_set_report_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;<a href="#enum_bt_hid_report_type">uint8 report_type</a>,<br>&nbsp;&nbsp;uint8 report_id,<br>&nbsp;&nbsp;uint8array report_data<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_hid enumerations</header><div class="enum" id="enum_bt_hid_state"><header>bt_hid_state</header><div><p>These values describe state changes for HID connections.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_hid_state_boot_mode</td><td>The Host has set the Device to use only Boot Reports. 
                The send_input_report command should not be used in this state.</td></tr><tr><td>1</td><td>bt_hid_state_report_mode</td><td>The Host has set the Device to use Report Mode. 
                The send_boot_report command should not be used in this state. This is the default state a HID connection is in.</td></tr><tr><td>3</td><td>bt_hid_state_suspend</td><td>The Host has entered a state where normal operation is no longer required from the Device,
                 for example gone to sleep mode. The HID Device may also enter a power saving mode or even disconnect from the Host.</td></tr><tr><td>4</td><td>bt_hid_state_exit_suspend</td><td>The Host has resumed normal operation and the Device should exit any power saving mode it may have been in.</td></tr><tr><td>5</td><td>bt_hid_state_virtual_cable_unplug</td><td>The Host has requested to disassociate the Device with the Host,
                 and will delete the bonding information it has associated with the Device. 
                 The connection will be automatically closed by the HID Device and its corresponding bonding deleted.</td></tr></table></div></div><div class="enum" id="enum_bt_hid_get_report_params"><header>bt_hid_get_report_params</header><div><p>These values indicate which parameters should be ignored in the bt_hid_get_report events. 
            The response should be sent with the same value.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_hid_params_no_id_no_max_size</td><td>The Host has requested the current state for the report unambiguously specified by Report Type, 
                with no maximum data size constraints. Report ID and Max Bytes should be ignored.</td></tr><tr><td>1</td><td>bt_hid_params_with_id_no_max_size</td><td>The Host has requested the current state for the report identified by Report Type and Report ID,
                 with no maximum data size constraints. Max Bytes should be ignored.</td></tr><tr><td>2</td><td>bt_hid_params_no_id_with_max_size</td><td>The Host has requested the current state for the report unambiguously specified by Report Type.
                 Report ID should be ignored. Only the first N bytes of the report, as specified by Max Bytes, shall be sent.</td></tr><tr><td>3</td><td>bt_hid_params_with_id_with_max_size</td><td>The Host has requested the current state for the report identified by Report Type and Report ID.
                 Only the first N-1 bytes of the report, as specified by Max Bytes, shall be sent. (Report ID will take up 1 byte.)</td></tr></table></div></div><div class="enum" id="enum_bt_hid_report_type"><header>bt_hid_report_type</header><div><p></p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>bt_hid_report_type_other</td><td>Other Report</td></tr><tr><td>1</td><td>bt_hid_report_type_input</td><td>Input Report</td></tr><tr><td>2</td><td>bt_hid_report_type_output</td><td>Output Report</td></tr><tr><td>3</td><td>bt_hid_report_type_feature</td><td>Feature Report</td></tr></table></div></div></div></div><div class="cls" id="cls_bt_rfcomm"><header>RFCOMM (bt_rfcomm)</header>These commands and events are related to the establishment of Bluetooth Classic RFCOMM connections as specified in the Serial Port Profile SPP).<div class="msg_type"><header>bt_rfcomm commands</header><div class="command" id="cmd_bt_rfcomm_modem_status"><header >bt_rfcomm_modem_status</header><div><p>This command sets modem control status bits for RFCOMM connection. This is a legacy support feature and <b>SHOULD NOT BE USED FOR FLOW CONTROL</b>.<br>
            For description and meaning of bits in this field see the ETSI TS 07.10 specification. 
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                   Endpoint ID assigned to the RFCOMM connection
                    </td></tr><tr><td>5</td><td> uint8</td><td> modem</td><td> 
                    New values of the modem status bits.
                    </td></tr><tr><td>6</td><td> uint8</td><td> mask</td><td> 
                    Bitmask of which bits are changed.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_modem_status(endpoint, modem, mask)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_modem_status(uint8 endpoint, uint8 modem, uint8 mask);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_modem_status_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_modem_status_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_open"><header >bt_rfcomm_open</header><div><p>Open an RFCOMM channel to remote device. An existing connection, or a connection attempt before the page timeout expires, 
            can be closed with the <a href="#cmd_endpoint_close">endpoint_close</a> command.
            <br><br>
            NOTE: Controller does not allow starting a Classic BR/EDR connection while a classic discovery 
            process in in progress. Please terminate any classic discovery with 
            <a href="#cmd_bt_gap_cancel_discovery">
            bt_gap_cancel_discovery</a> 
            command prior to starting the RFCOMM connection.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x08 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> 
                Bluetooth address of the remote device in little endian format
                </td></tr><tr><td>10</td><td> uint8</td><td> streaming_destination</td><td> 
                    Streaming destination for the connection endpoint.
                    <br><br>
                    Endpoint 'SCRIPT' is a special case in the BGAPI mode for RFCOMM. 
                    Data events are sent 
                    to script and in addition also to UART. Please note that if size event exeeds
                    size of 256 (inclusive of headers) it will be rejected by the script 
                    intepreter.                     
                    </td></tr><tr><td>11</td><td> uint8array</td><td> uuid</td><td> 
                UUID of the profile to connect to:<ul><li>uuid16, 2 bytes: 16-bit UUID for searching RFCOMM port</li><li>uuid32, 4 bytes: 32-bit UUID for searching RFCOMM port</li><li>uuid128, 16 bytes: 128-bit UUID for searching RFCOMM port</li></ul>
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> Unsigned 8-bit integer</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_open(address, streaming_destination, uuid_len, uuid_data)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_open(bd_addr *address, uint8 streaming_destination, uint8 uuid_len, const uint8 *uuid_data);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_open_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_open_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_rfcomm_opened">bt_rfcomm_opened</a></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_open_port"><header >bt_rfcomm_open_port</header><div><p>This command can be used to open an RFCOMM channel to a remote device using a fixed RFCOMM port number. This bypasses the Service Discovery Protocol procedure
            for retrieving the RFCOMM port from the remote device's Serial Port Profile SDP entry, thus speeding up connection establishment.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x08 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> 
                Bluetooth address of the remote device in little endian format
                </td></tr><tr><td>10</td><td> uint8</td><td> streaming_destination</td><td> 
                    Streaming destination for the connection endpoint.
                    <br><br>
                    Endpoint 'SCRIPT' is a special case in the BGAPI mode for RFCOMM. 
                    Data events are sent 
                    to script and in addition also to UART. Please note that if size event exeeds
                    size of 256 (inclusive of headers) it will be rejected by the script 
                    intepreter.                     
                    </td></tr><tr><td>11</td><td> uint8</td><td> port</td><td> 
                RFCOMM port
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> Unsigned 8-bit integer</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_open_port(address, streaming_destination, port)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_open_port(bd_addr *address, uint8 streaming_destination, uint8 port);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_open_port_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_open_port_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_rfcomm_opened">bt_rfcomm_opened</a></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_set_modem_status_default"><header >bt_rfcomm_set_modem_status_default</header><div><p>This command sets starting value modem control status bits for new outogoing RFCOMM connections. 
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> modem</td><td> 
                    Starting values of the modem status bits.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_set_modem_status_default(modem)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_set_modem_status_default(uint8 modem);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_set_modem_status_default_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_set_modem_status_default_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_start_server"><header >bt_rfcomm_start_server</header><div><p>
            This command can be used to start a RFCOMM server as defined in the referenced SDP-entry.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> sdp_id</td><td> ID of the SDP entry defined in project configuration file</td></tr><tr><td>5</td><td> uint8</td><td> streaming_destination</td><td> 
                    Streaming destination endpoint for the connection. This should be one of the fixed endpoints. While a dynamic connection endpoint will work for proxying data
                    coming from an RFCOMM connection to another connection endpoint, there is no guarantee that the destination endpoint will be there when an incoming RFCOMM 
                    connection is established.<br><br>

                    Endpoint 'SCRIPT' is a special case in the BGAPI mode for RFCOMM. 
                    Data events are sent 
                    to script and in addition also to UART. Please note that if size event exeeds
                    size of 256 (inclusive of headers) it will be rejected by the script 
                    intepreter.                      
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_start_server(sdp_id, streaming_destination)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_start_server(uint8 sdp_id, uint8 streaming_destination);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_start_server_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_start_server_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_start_server_port"><header >bt_rfcomm_start_server_port</header><div><p>
            This command can be used to start a RFCOMM server on specific port.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> port</td><td> port to use </td></tr><tr><td>5</td><td> uint8</td><td> streaming_destination</td><td> 
                    Streaming destination endpoint for the connection. This should be one of the fixed endpoints. While a dynamic connection endpoint will work for proxying data
                    coming from an RFCOMM connection to another connection endpoint, there is no guarantee that the destination endpoint will be there when an incoming RFCOMM 
                    connection is established.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_start_server_port(port, streaming_destination)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_start_server_port(uint8 port, uint8 streaming_destination);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_start_server_port_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_start_server_port_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_stop_server"><header >bt_rfcomm_stop_server</header><div><p>
            This command can be used to stop an RFCOMM server.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> sdp_id</td><td> ID of the SDP entry defined in the project configuration file.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_stop_server(sdp_id)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_stop_server(uint8 sdp_id);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_stop_server_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_stop_server_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_rfcomm_stop_server_port"><header >bt_rfcomm_stop_server_port</header><div><p>
            This command can be used to stop an RFCOMM server that has been started ona port.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> port</td><td> port server is listening.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_rfcomm_stop_server_port(port)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_rfcomm_stop_server_port(uint8 port);<br><br>/* Response id */<br>dumo_rsp_bt_rfcomm_stop_server_port_id<br><br>/* Response structure */<br>struct dumo_msg_bt_rfcomm_stop_server_port_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>bt_rfcomm events</header><div class="event" id="evt_bt_rfcomm_opened"><header >bt_rfcomm_opened</header><div><p>This event indicates the establishment of an RFCOMM connection.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                   Endpoint ID assigned to the RFCOMM connection
                    </td></tr><tr><td>5-10</td><td> bd_addr</td><td> address</td><td> 
                    Bluetooth address of the remote Bluetooth Classic device in little endian format.
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_rfcomm_opened(endpoint, address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_rfcomm_opened_id<br><br>/* event structure*/<br>struct dumo_msg_bt_rfcomm_opened_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_rfcomm_modem_status"><header >bt_rfcomm_modem_status</header><div><p>This event indicates change in modem control signals.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                   Endpoint ID assigned to the RFCOMM connection
                    </td></tr><tr><td>5</td><td> uint8</td><td> modem</td><td> 
                    Value of the modem status. For description and meaning of bits in this field see ETSI TS 07.10.
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_rfcomm_modem_status(endpoint, modem)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_rfcomm_modem_status_id<br><br>/* event structure*/<br>struct dumo_msg_bt_rfcomm_modem_status_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;uint8 modem<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_rfcomm_incoming_rejected"><header >bt_rfcomm_incoming_rejected</header><div><p>This event indicates that incoming rfcomm connection was rejected due being low in memory.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> 
                Bluetooth address of the remote device in little endian format
                </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_rfcomm_incoming_rejected(address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_rfcomm_incoming_rejected_id<br><br>/* event structure*/<br>struct dumo_msg_bt_rfcomm_incoming_rejected_evt_t<br>{<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_bt_rfcomm_credit_starvation"><header >bt_rfcomm_credit_starvation</header><div><p>
			This event indicates that outgoing data traffic has possibly been stuck. If there
			is no valid reason why the other end has not sent us flow control credits then the connection
			should be closed.
			</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x04 </td><td>class</td><td>Message class:RFCOMM</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                   Endpoint ID assigned to the RFCOMM connection
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_rfcomm_credit_starvation(endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_rfcomm_credit_starvation_id<br><br>/* event structure*/<br>struct dumo_msg_bt_rfcomm_credit_starvation_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_bt_sdp"><header>Service Discovery Profile (bt_sdp)</header>The commands and events in this are related to the Service Discovery Profile (SDP).<div class="msg_type"><header>bt_sdp commands</header><div class="command" id="cmd_bt_sdp_add_entry"><header >bt_sdp_add_entry</header><div><p>
            This function load custom defined SDP record into the SDP server.<br>
            Note that this funtion does not verify the correctness of the record at all.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> sdp_id</td><td> ID of the SDP entry to be loaded. Range from 1000 to 2000</td></tr><tr><td>8</td><td> uint8array</td><td> record</td><td> SDP record</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_sdp_add_entry(sdp_id, record_len, record_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_sdp_add_entry(uint32 sdp_id, uint8 record_len, const uint8 *record_data);<br><br>/* Response id */<br>dumo_rsp_bt_sdp_add_entry_id<br><br>/* Response structure */<br>struct dumo_msg_bt_sdp_add_entry_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_sdp_delete_entry"><header >bt_sdp_delete_entry</header><div><p>
            This function removes custom defined SDP record from the SDP server.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> sdp_id</td><td> ID of the SDP entry to be loaded. Range from 1000 to 2000</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_sdp_delete_entry(sdp_id)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_sdp_delete_entry(uint32 sdp_id);<br><br>/* Response id */<br>dumo_rsp_bt_sdp_delete_entry_id<br><br>/* Response structure */<br>struct dumo_msg_bt_sdp_delete_entry_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_sdp_load_entry"><header >bt_sdp_load_entry</header><div><p>
            This command can be used to load an SDP entry from the internal filesystem to the SDP server.
            <br>NOTE: command only loads SDP record. It does not do anything else. Like start RFCOMM server
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> sdp_id</td><td> ID of the SDP entry defined in the project configuration file. See the Bluetooth Smart Ready Serial Port Profile Application Notes for details</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_sdp_load_entry(sdp_id)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_sdp_load_entry(uint32 sdp_id);<br><br>/* Response id */<br>dumo_rsp_bt_sdp_load_entry_id<br><br>/* Response structure */<br>struct dumo_msg_bt_sdp_load_entry_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_bt_sdp_search_rfcomm_port"><header >bt_sdp_search_rfcomm_port</header><div><p>
            This command can be used to search for Serial Port Profile (SPP) services in a Bluetooth Classic device. The reply is an event specifying the RFCOMM port found.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> 
                    Bluetooth device address of the remote device in little endian format
                    </td></tr><tr><td>10</td><td> uint8array</td><td> uuid</td><td> 
                UUID is one of the following:<ul><li>uuid16, 2 bytes: 16-bit UUID for searching RFCOMM port</li><li>uuid32, 4 bytes: 32-bit UUID for searching RFCOMM port</li><li>uuid128, 16 bytes: 128-bit UUID for RFCOMM port</li></ul>
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call bt_sdp_search_rfcomm_port(address, uuid_len, uuid_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_bt_sdp_search_rfcomm_port(bd_addr *address, uint8 uuid_len, const uint8 *uuid_data);<br><br>/* Response id */<br>dumo_rsp_bt_sdp_search_rfcomm_port_id<br><br>/* Response structure */<br>struct dumo_msg_bt_sdp_search_rfcomm_port_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_bt_sdp_search_rfcomm_port">bt_sdp_search_rfcomm_port</a></td></tr></table></div></div></div><div class="msg_type"><header>bt_sdp events</header><div class="event" id="evt_bt_sdp_search_rfcomm_port"><header >bt_sdp_search_rfcomm_port</header><div><p>This event indicates the SDP search result.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x08 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x06 </td><td>class</td><td>Message class:Service Discovery Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> request_handle</td><td> Reserved; should be set to zero</td></tr><tr><td>8-9</td><td> uint16</td><td> status</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>10</td><td> uint8</td><td> port</td><td> RFCOMM port number</td></tr><tr><td>11</td><td> uint8array</td><td> service_name</td><td> RFCOMM service name</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event bt_sdp_search_rfcomm_port(request_handle, status, port, service_name_len, service_name_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_bt_sdp_search_rfcomm_port_id<br><br>/* event structure*/<br>struct dumo_msg_bt_sdp_search_rfcomm_port_evt_t<br>{<br>&nbsp;&nbsp;uint32 request_handle,<br>&nbsp;&nbsp;uint16 status,<br>&nbsp;&nbsp;uint8 port,<br>&nbsp;&nbsp;uint8array service_name<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_dfu"><header>Device Firmware Upgrade (dfu)</header>These commands and events are related to controlling firmware update over the configured host interface and are available only when the module has been booted into DFU mode.
        <br><br>
            <b>The DFU process:</b>
            <ol>
                <li>Boot device to DFU mode with <a href="#cmd_dfu_reset">DFU reset command</a> </li>
                <li>Wait for <a href="#evt_dfu_boot">DFU boot event</a> </li>
                <li>Send command <a href="#cmd_dfu_flash_set_address">Flash Set Address</a> to start the firmware update</li>
                <li>Upload the firmware with <a href="#cmd_dfu_flash_upload">Flash Upload commands</a> until all the data has been uploaded </li>
                <li>Send <a href="#cmd_dfu_flash_upload_finish">Flash Upload Finish </a> when all the data has been uploaded </li>
                <li>Finalize the DFU firmware update with <a href="#cmd_dfu_reset"> Reset command.</a> </li>
            </ol>
        <br><br>
        	Bootloader checks the CRC checksum from the uploaded image and the module will remain in DFU mode if
        	it does not match.
        <br><br>    
            DFU mode is using UART baudrate from the hardware configuration of the firmware. Default baudrate 115200 is used if firmware is missing or firmware content does not match with CRC checksum.
        <br><br>
        <div class="msg_type"><header>dfu commands</header><div class="command" id="cmd_dfu_flash_set_address"><header >dfu_flash_set_address</header><div><p>After re-booting the local device into DFU mode, this command can be used to define the starting address on the flash to where the new firmware will be written in.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> address</td><td> The offset in the flash where the new firmware is uploaded to. Always use the value 0x00000000.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call dfu_flash_set_address(address)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_dfu_flash_set_address(uint32 address);<br><br>/* Response id */<br>dumo_rsp_dfu_flash_set_address_id<br><br>/* Response structure */<br>struct dumo_msg_dfu_flash_set_address_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_dfu_flash_upload"><header >dfu_flash_upload</header><div><p>This command can be used to upload the whole firmware image file in to the Bluetooth module. The recommended payload size of the command is 128 bytes, so multiple commands need to be issued one after the other until the whole .bin firmware image file is uploaded to the module. The next address of the flash sector in memory to write to is automatically updated by the bootloader after each individual command.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> data</td><td> An array of data which will be written onto the flash.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call dfu_flash_upload(data_len, data_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_dfu_flash_upload(uint8 data_len, const uint8 *data_data);<br><br>/* Response id */<br>dumo_rsp_dfu_flash_upload_id<br><br>/* Response structure */<br>struct dumo_msg_dfu_flash_upload_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_dfu_flash_upload_finish"><header >dfu_flash_upload_finish</header><div><p>This command can be used to tell to the device that the DFU file has been fully uploaded. To return the device back to normal mode the command <a href="#cmd_dfu_reset">DFU Reset </a> must be issued next.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call dfu_flash_upload_finish()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_dfu_flash_upload_finish();<br><br>/* Response id */<br>dumo_rsp_dfu_flash_upload_finish_id<br><br>/* Response structure */<br>struct dumo_msg_dfu_flash_upload_finish_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_dfu_reset"><header >dfu_reset</header><div><p>This command can be used to reset the system. This command does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) after re-boot. </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> dfu</td><td> Boot mode:
                    <ul>
                    <li><b>0:</b> Normal reset</dd>
                    <li><b>1:</b> Boot to DFU mode</dd>
                    </ul>
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Command does not have response</caption></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call dfu_reset(dfu)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_dfu_reset(uint8 dfu);<br><br>/* Command does not have response */<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_system_boot">system_boot</a></td><td>Sent after the device has booted into normal mode</td></tr><tr><td><a href="#evt_dfu_boot">dfu_boot</a></td><td>Sent after the device has booted into DFU mode</td></tr></table></div></div></div><div class="msg_type"><header>dfu events</header><div class="event" id="evt_dfu_boot"><header >dfu_boot</header><div><p>This event indicates that the module booted into DFU mode, and is now ready to receive commands related to device firmware upgade (DFU).</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x00 </td><td>class</td><td>Message class:Device Firmware Upgrade</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> version</td><td> The version of the bootloader</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event dfu_boot(version)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_dfu_boot_id<br><br>/* event structure*/<br>struct dumo_msg_dfu_boot_evt_t<br>{<br>&nbsp;&nbsp;uint32 version<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_endpoint"><header>Endpoint (endpoint)</header>
            These commands and events are related to the control of endpoints. They allow the creation and deletion of endpoints as well as configuration of data routing.
            <br><br>Predefined endpoints ID's are:
            <ul>
                <li><b>0:</b> UART               </li>
                <li><b>1:</b> SCRIPT             </li>
                <li><b>3:</b> SPI1 (only if defined in hardware configuration)</li>
                <li><b>4:</b> SPI2 (only if defined in hardware configuration)</li>
                <li><b>31:</b> DROP              </li>
            </ul>
           <br><br>
            Note the difference between these endpoint ID's and the  <a href="#enum_endpoint_types">endpoint types</a>
            is that endpoint types describe different categories. 
            Each endpoint has an endpoint type which describes what kind of endpoint it is. There may be multiple endpoints 
            which have the same type. Each endpoint has exactly one ID, and each ID points to exactly one endpoint.
            <br>
        <div class="msg_type"><header>endpoint commands</header><div class="command" id="cmd_endpoint_close"><header >endpoint_close</header><div><p>This command can be used to close an RFCOMM endpoint
            , LE cable replacement endpoint, or a BLE connection. 
            This command must always be used to close an endpoint with WAIT_CLOSE status
             when the remote side has closed the RFCOMM or LE cable replacement connection.
              This is to free the memory allocated by the endpoint for future reuse in the case 
              when the remote side closes the connection.<br><br>
              Note : this command may not be issued inside <a href="#evt_endpoint_data">
            endpoint_data</a> event handler in BgScript.
              </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The index of the RFCOMM/LE cable replacement endpoint to close or the connection handle ID of the BLE connection to be closed. The connection handle ID is reported for example in the event le_connection_opened.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> The endpoint that was closed</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call endpoint_close(endpoint)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_endpoint_close(uint8 endpoint);<br><br>/* Response id */<br>dumo_rsp_endpoint_close_id<br><br>/* Response structure */<br>struct dumo_msg_endpoint_close_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_endpoint_status">endpoint_status</a></td><td>Sent when endpoint status changes</td></tr></table></div></div><div class="command" id="cmd_endpoint_read_counters"><header >endpoint_read_counters</header><div><p>This command can be used to read the data performance counters (data sent counter and data received counter) of an endpoint.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The endpoint's handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x0b </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> </td></tr><tr><td>7-10</td><td> uint32</td><td> tx</td><td> Amount of data sent to this endpoint</td></tr><tr><td>11-14</td><td> uint32</td><td> rx</td><td> Amount of data received from this endpoint</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call endpoint_read_counters(endpoint)(result, endpoint, tx, rx)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_endpoint_read_counters(uint8 endpoint);<br><br>/* Response id */<br>dumo_rsp_endpoint_read_counters_id<br><br>/* Response structure */<br>struct dumo_msg_endpoint_read_counters_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;uint32 tx,<br>&nbsp;&nbsp;uint32 rx<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_endpoint_send"><header >endpoint_send</header><div><p>This command can be used to send data to the defined endpoint.
            <br><br>When this command is issued data to be sent is placed to send queue for sending, except for SPI endpoints. 
            In case of SPI endpoints data is immediately sent over the interface and transfer is complete once 
            the response to this command has been received.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The index of the endpoint to which the data will be sent.</td></tr><tr><td>5</td><td> uint8array</td><td> data</td><td> The RAW data which will be written or sent</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
							Result code
							<ul>
							<li><b>0:</b> success</li>
							<li><b>0x018e:</b> Internal buffers are full and the data was discarded and not sent.<br>The host should resend the data again later.
							The host can optionally wait for an <a href="#evt_endpoint_status">endpoint_status event</a> and check that 
							<a href="#define_endpoint_endpoint_flags">endpoint_FLAG_FULL </a> is not set.</li>
							<li><b>Non-zero:</b> an other error occurred</li>
							</ul>
							For other values refer to the <a href="#error_codes">Error codes</a>
					</td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> 
                    The endpoint to which the data was written
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call endpoint_send(endpoint, data_len, data_data)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_endpoint_send(uint8 endpoint, uint8 data_len, const uint8 *data_data);<br><br>/* Response id */<br>dumo_rsp_endpoint_send_id<br><br>/* Response structure */<br>struct dumo_msg_endpoint_send_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_endpoint_set_active"><header >endpoint_set_active</header><div><p>This command can be used to set the endpoint active or inactive.
			When the endpoint is inactive, any incoming data will be paused, and no data may be sent out.
			Not all endpoint types can set changed inactive. Currently only rfcomm endpoints can be set inactive.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The endpoint's handle</td></tr><tr><td>5</td><td> uint8</td><td> active</td><td> Active state (0 or 1).</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call endpoint_set_active(endpoint, active)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_endpoint_set_active(uint8 endpoint, uint8 active);<br><br>/* Response id */<br>dumo_rsp_endpoint_set_active_id<br><br>/* Response structure */<br>struct dumo_msg_endpoint_set_active_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_endpoint_status">endpoint_status</a></td></tr></table></div></div><div class="command" id="cmd_endpoint_set_streaming_destination"><header >endpoint_set_streaming_destination</header><div><p>This command can be used to set the destination into which data from an endpoint will be routed to.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The endpoint which to control</td></tr><tr><td>5</td><td> uint8</td><td> destination_endpoint</td><td> The destination for the data
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call endpoint_set_streaming_destination(endpoint, destination_endpoint)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_endpoint_set_streaming_destination(uint8 endpoint, uint8 destination_endpoint);<br><br>/* Response id */<br>dumo_rsp_endpoint_set_streaming_destination_id<br><br>/* Response structure */<br>struct dumo_msg_endpoint_set_streaming_destination_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_endpoint_status">endpoint_status</a></td><td>Sent when endpoint status changes</td></tr></table></div></div></div><div class="msg_type"><header>endpoint events</header><div class="event" id="evt_endpoint_syntax_error"><header >endpoint_syntax_error</header><div><p>
            This event indicates that a protocol error was detected in BGAPI command parser. 
            This event is triggered if a BGAPI command from the host contains syntax error(s), 
 			or if a command is only partially sent, in which case the BGAPI parser has a 1 
 			second command timeout by default. In practice, the latter case happens if a byte 
 			belonging to a command is sent not before a timeout of 1 second since the previous 
 			byte. The default timeout can be changed from 1ms to 4s via the "timeout" parameter
 			 of the attribute &lt;uart&gt; in the hardware.xml firmware project file. 
 			 Any partial or wrongly formatted command will be discarded.            
 			 </p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> Endpoint of the connection</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event endpoint_syntax_error(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_endpoint_syntax_error_id<br><br>/* event structure*/<br>struct dumo_msg_endpoint_syntax_error_evt_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_endpoint_data"><header >endpoint_data</header><div><p>This event indicates incoming data from an endpoint.<br><br>
            Note : <a href="#cmd_endpoint_close">
            endpoint_close</a> command must not be used in BgScript handler for this event.
            </p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The endpoint which received this data, i.e. to which it was sent.</td></tr><tr><td>5</td><td> uint8array</td><td> data</td><td> The raw data</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event endpoint_data(endpoint, data_len, data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_endpoint_data_id<br><br>/* event structure*/<br>struct dumo_msg_endpoint_data_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;uint8array data<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_endpoint_status"><header >endpoint_status</header><div><p>This event indicates an endpoint's status.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> The index of the endpoint whose status this event describes</td></tr><tr><td>5-8</td><td> uint32</td><td> <a href="#enum_endpoint_types">type</a></td><td> Unsigned 32-bit integer</td></tr><tr><td>9</td><td> int8</td><td> destination_endpoint</td><td> The index of the endpoint to which the incoming data goes.</td></tr><tr><td>10</td><td> uint8</td><td> flags</td><td> Flags which indicate the mode of endpoint</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event endpoint_status(endpoint, type, destination_endpoint, flags)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_endpoint_status_id<br><br>/* event structure*/<br>struct dumo_msg_endpoint_status_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint,<br>&nbsp;&nbsp;<a href="#enum_endpoint_types">uint32 type</a>,<br>&nbsp;&nbsp;int8 destination_endpoint,<br>&nbsp;&nbsp;uint8 flags<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_endpoint_closing"><header >endpoint_closing</header><div><p>
            This event indicates that an endpoint is closing or that the remote end has terminated the connection. This event should be acknowledged by calling the <a href="#cmd_endpoint_close">endpoint_close</a> command or otherwise the firmware will not re-use the endpoint index.
            </p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> reason</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> Endpoint handle. Values:<ul><li><b>0xff:</b> connection failed without associated endpoint</li><li><b>Others: </b>Handle for closed endpoint</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event endpoint_closing(reason, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_endpoint_closing_id<br><br>/* event structure*/<br>struct dumo_msg_endpoint_closing_evt_t<br>{<br>&nbsp;&nbsp;uint16 reason,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_endpoint_closed"><header >endpoint_closed</header><div><p>
            This event indicates that an RFCOMM endpoint has been closed by the safety timer. After endpoint_closing
            event user should close the endpoint to release the resources taken by the enpoint. If user fails to
            do so in about 5 seconds then module SW will release resources and dispatch this event.
            </p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0b </td><td>class</td><td>Message class:Endpoint</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> Endpoint handle. Values:<ul><li><b>0xff:</b> connection failed without associated endpoint</li><li><b>Others: </b>Handle for closed endpoint</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event endpoint_closed(endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_endpoint_closed_id<br><br>/* event structure*/<br>struct dumo_msg_endpoint_closed_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>endpoint enumerations</header><div class="enum" id="enum_endpoint_types"><header>endpoint_types</header><div><p>These values define the endpoint types. Please note that there may be multiple endpoints with type</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>endpoint_free</td><td>Endpoint is not in use</td></tr><tr><td>1</td><td>endpoint_uart</td><td>UART</td></tr><tr><td>2</td><td>endpoint_script</td><td>Scripting</td></tr><tr><td>4</td><td>endpoint_reserved</td><td>Reserved for future use</td></tr><tr><td>16</td><td>endpoint_drop</td><td>Drop all data sent to this endpoint</td></tr><tr><td>32</td><td>endpoint_rfcomm</td><td>RFCOMM channel</td></tr><tr><td>64</td><td>endpoint_spi</td><td>SPI</td></tr><tr><td>128</td><td>endpoint_connection</td><td>Connection</td></tr><tr><td>512</td><td>endpoint_iap</td><td>iAP</td></tr><tr><td>1024</td><td>endpoint_l2cap</td><td>L2CAP</td></tr><tr><td>2048</td><td>endpoint_hid</td><td>HID</td></tr><tr><td>4096</td><td>endpoint_leserial</td><td>Bluetooth LE serial channel</td></tr></table></div></div></div><div class="msg_type"><header>endpoint defines</header><div class="enum" id="enum_endpoint_endpoint_flags"><header>endpoint_endpoint_flags</header><div><p></p><table class="ENUM_TABLE"><caption>Defines</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>1</td><td>ENDPOINT_FLAG_UPDATED</td><td>Endpoint status has been changed since last indication</td></tr><tr><td>2</td><td>ENDPOINT_FLAG_ACTIVE</td><td>Endpoint is active and can send and receive data</td></tr><tr><td>4</td><td>ENDPOINT_FLAG_STREAMING</td><td>Endpoint is in streaming mode. Data is sent and received from endpoint without framing</td></tr><tr><td>8</td><td>ENDPOINT_FLAG_BGAPI</td><td>Endpoint is configured for BGAPI. Data received is parsed as BGAPI commands. Also all BGAPI events and responses are sent to this endpoint</td></tr><tr><td>16</td><td>ENDPOINT_FLAG_WAIT_CLOSE</td><td>Endpoint is closed from the device side. Host needs to acknowledge by sending endpoint_close command to device with this endpoint as parameter</td></tr><tr><td>32</td><td>ENDPOINT_FLAG_CLOSING</td><td>Endpoint is closed from the host side and is waiting for the device to acknowledge closing of the endpoint</td></tr><tr><td>64</td><td>ENDPOINT_FLAG_FULL</td><td>Endpoint buffers are full and no data from host can be sent to it.
			<p>When more data can be sent to the endpoint, a new <a href="#evt_endpoint_status">endpoint_status event</a> will be generated with the updated flags.</p></td></tr></table></div></div></div></div><div class="cls" id="cls_flash"><header>Persistent Store (flash)</header>Thse commands and events can be used to manage the user data in the flash memory of the Bluetooth module. User data stored in PS keys within the flash memory is persistent across reset and power cycling of the module.<div class="msg_type"><header>flash commands</header><div class="command" id="cmd_flash_ps_dump"><header >flash_ps_dump</header><div><p>This command can be used to retrieve all PS keys and their current values. For each existing PS key a flash_pskey event will be generated which includes the corresponding PS key value.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call flash_ps_dump()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_flash_ps_dump();<br><br>/* Response id */<br>dumo_rsp_flash_ps_dump_id<br><br>/* Response structure */<br>struct dumo_msg_flash_ps_dump_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_flash_ps_key">flash_ps_key</a></td><td>PS Key contents</td></tr></table></div></div><div class="command" id="cmd_flash_ps_erase"><header >flash_ps_erase</header><div><p>This command can be used to erase a single PS key and its value from the Persistent Store.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> key</td><td> PS key to erase</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call flash_ps_erase(key)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_flash_ps_erase(uint16 key);<br><br>/* Response id */<br>dumo_rsp_flash_ps_erase_id<br><br>/* Response structure */<br>struct dumo_msg_flash_ps_erase_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_flash_ps_erase_all"><header >flash_ps_erase_all</header><div><p>This command can be used to erase all PS keys and their corresponding value.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call flash_ps_erase_all()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_flash_ps_erase_all();<br><br>/* Response id */<br>dumo_rsp_flash_ps_erase_all_id<br><br>/* Response structure */<br>struct dumo_msg_flash_ps_erase_all_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_flash_ps_load"><header >flash_ps_load</header><div><p>This command can be used for retrieving the value of the specified PS key.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> key</td><td> PS key of the value to be retrieved</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8array</td><td> value</td><td> The returned value of the specified PS key.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call flash_ps_load(key)(result, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_flash_ps_load(uint16 key);<br><br>/* Response id */<br>dumo_rsp_flash_ps_load_id<br><br>/* Response structure */<br>struct dumo_msg_flash_ps_load_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_flash_ps_save"><header >flash_ps_save</header><div><p>This command can be used to store a value into the specified PS key.
            The allowed PS key range is from 0x4000 to 0x407F.
            Maximum length of value  is 250 bytes. 
            Maximum storage space is 4 KB and this is shared with system internal keys.
            Available storage space depends on how much storage space the application will use. In addition 20 bytes of metadata is stored for each PS item.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> key</td><td> PS key</td></tr><tr><td>6</td><td> uint8array</td><td> value</td><td> Value to store into the specified PS key.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call flash_ps_save(key, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_flash_ps_save(uint16 key, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_flash_ps_save_id<br><br>/* Response structure */<br>struct dumo_msg_flash_ps_save_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>flash events</header><div class="event" id="evt_flash_ps_key"><header >flash_ps_key</header><div><p>This event indicates that the flash_ps_dump command was given. It returns a single PS key and its value. There can be multiple events if multiple PS keys exist.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0d </td><td>class</td><td>Message class:Persistent Store</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> key</td><td> PS key</td></tr><tr><td>6</td><td> uint8array</td><td> value</td><td> Current value of the PS key specified in this event.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event flash_ps_key(key, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_flash_ps_key_id<br><br>/* event structure*/<br>struct dumo_msg_flash_ps_key_evt_t<br>{<br>&nbsp;&nbsp;uint16 key,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_gatt"><header>Generic Attribute Profile (gatt)</header>The commands and events in this class can be used to browse and manage attributes in a remote GATT server.<div class="msg_type"><header>gatt commands</header><div class="command" id="cmd_gatt_discover_characteristics"><header >gatt_discover_characteristics</header><div><p>This command can be used to discover all characteristics of the defined GATT service from a remote GATT database. This command generates a unique gatt_characteristic event for every discovered characteristic. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that this GATT procedure has succesfully completed or failed with error.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> service</td><td> GATT service handle. This value is normally received from the <a href="#evt_gatt_service">gatt_service</a> event.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_discover_characteristics(connection, service)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_discover_characteristics(uint8 connection, uint32 service);<br><br>/* Response id */<br>dumo_rsp_gatt_discover_characteristics_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_discover_characteristics_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_characteristic">gatt_characteristic</a></td><td>Discovered characteristic from remote GATT database.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_discover_characteristics_by_uuid"><header >gatt_discover_characteristics_by_uuid</header><div><p>This command can be used to discover all the characteristics of the specified GATT service in a remote GATT database having the specified UUID. This command
generates a unique gatt_characteristic event for every discovered
characteristic having the specified UUID. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that
this GATT procedure has successfully completed or failed with error.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> service</td><td> GATT service handle. This value is normally received from the <a href="#evt_gatt_service">gatt_service</a> event.</td></tr><tr><td>9</td><td> uint8array</td><td> uuid</td><td> Characteristic UUID, first byte is the length of UUID and rest is UUID in little-endian format</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_discover_characteristics_by_uuid(connection, service, uuid_len, uuid_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_discover_characteristics_by_uuid(uint8 connection, uint32 service, uint8 uuid_len, const uint8 *uuid_data);<br><br>/* Response id */<br>dumo_rsp_gatt_discover_characteristics_by_uuid_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_discover_characteristics_by_uuid_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_characteristic">gatt_characteristic</a></td><td>Discovered characteristic from remote GATT database.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_discover_descriptors"><header >gatt_discover_descriptors</header><div><p>This command can be used to discover all the descriptors of the specified remote GATT characteristics in a remote GATT database. This command generates a unique gatt_descriptor event for every discovered descriptor. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that this GATT procedure has succesfully completed or failed with error.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_discover_descriptors(connection, characteristic)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_discover_descriptors(uint8 connection, uint16 characteristic);<br><br>/* Response id */<br>dumo_rsp_gatt_discover_descriptors_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_discover_descriptors_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_descriptor">gatt_descriptor</a></td><td>Discovered descriptor from remote GATT database.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_discover_primary_services"><header >gatt_discover_primary_services</header><div><p>This command can be used to discover all the primary services of a remote GATT database. This command generates a unique gatt_service event for 
            every discovered primary service. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that this GATT procedure 
            has successfully completed or failed with error.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_discover_primary_services(connection)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_discover_primary_services(uint8 connection);<br><br>/* Response id */<br>dumo_rsp_gatt_discover_primary_services_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_discover_primary_services_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_service">gatt_service</a></td><td>Discovered service from remote GATT database</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_discover_primary_services_by_uuid"><header >gatt_discover_primary_services_by_uuid</header><div><p>This command can be used to discover primary services with the specified UUID in a remote GATT database. This command generates unique gatt_service event for every discovered primary service. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that this GATT procedure has succesfully completed or failed with error.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5</td><td> uint8array</td><td> uuid</td><td> Characteristic UUID, first byte is the length of UUID and rest is UUID in little-endian format</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_discover_primary_services_by_uuid(connection, uuid_len, uuid_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_discover_primary_services_by_uuid(uint8 connection, uint8 uuid_len, const uint8 *uuid_data);<br><br>/* Response id */<br>dumo_rsp_gatt_discover_primary_services_by_uuid_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_discover_primary_services_by_uuid_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_service">gatt_service</a></td><td>Discovered service from remote GATT database.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_execute_characteristic_value_write"><header >gatt_execute_characteristic_value_write</header><div><p>This command can be used to commit or cancel previously queued writes to a long characteristic of a remote GATT server.
            Writes are sent to queue with <a href="#cmd_gatt_prepare_characteristic_value_write">prepare_characteristic_value_write</a> command. 
            Content, offset and length of queued values are validated by this procedure. A received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a>
            event indicates that all data has been written successfully or that an error response has been received.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0c </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_gatt_execute_write_flag">flags</a></td><td> Unsigned 8-bit integer</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0c </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_execute_characteristic_value_write(connection, <a href="#enum_gatt_execute_write_flag">flags</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_execute_characteristic_value_write(uint8 connection, <a href="#enum_gatt_execute_write_flag">uint8 flags</a>);<br><br>/* Response id */<br>dumo_rsp_gatt_execute_characteristic_value_write_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_execute_characteristic_value_write_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_find_included_services"><header >gatt_find_included_services</header><div><p>This command can be used to find out if a service of a remote GATT database includes one or more other services. This command generates a unique gatt_service_completed event for each included service. This command generates a unique gatt_service event for every discovered service. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that this GATT procedure has successfully completed or failed with error.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x10 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> service</td><td> GATT service handle. This value is normally received from the <a href="#evt_gatt_service">gatt_service</a> event.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x10 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_find_included_services(connection, service)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_find_included_services(uint8 connection, uint32 service);<br><br>/* Response id */<br>dumo_rsp_gatt_find_included_services_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_find_included_services_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_service">gatt_service</a></td><td>Discovered service from remote GATT database.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_prepare_characteristic_value_write"><header >gatt_prepare_characteristic_value_write</header><div><p>This command can be used to add a characteristic value to the write queue of a remote GATT server. 
            This command can be used in cases where very long attributes need to be written, or a set of values needs to be written atomically.
            In all cases where the amount of data to transfer fits into the BGAPI payload the command 
            <a href="#cmd_gatt_write_characteristic_value">gatt_write_characteristic_value</a> is recommended for writing long values since it transparently 
            performs the prepare_write and execute_write commands. A received <a href="#evt_gatt_characteristic_value">evt_gatt_characteristic_value</a> event can
            be used to verify that the data has been transmitted. Writes are executed or cancelled with the <a href="#cmd_gatt_execute_characteristic_value_write">execute_characteristic_value_write</a> command.
            Whether the writes succeeded or not are indicated in the response of the <a href="#cmd_gatt_execute_characteristic_value_write">execute_characteristic_value_write</a> command.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7-8</td><td> uint16</td><td> offset</td><td> Offset of the characteristic value</td></tr><tr><td>9</td><td> uint8array</td><td> value</td><td> Value to write into the specified characteristic of the remote GATT database</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_prepare_characteristic_value_write(connection, characteristic, offset, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_prepare_characteristic_value_write(uint8 connection, uint16 characteristic, uint16 offset, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_prepare_characteristic_value_write_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_prepare_characteristic_value_write_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_read_characteristic_value"><header >gatt_read_characteristic_value</header><div><p>This command can be used to read the value of a characteristic from a remote GATT database. A single <a href="#evt_gatt_characteristic_value">
            gatt_characteristic_value</a> event is generated 
            if the length of the characteristic value returned by the remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value 
            exceeds the size of the GATT MTU more than one <a href="#evt_gatt_characteristic_value">
            gatt_characteristic_value</a> event is generated because the firmware will automatically use the "read long" 
            GATT procedure. A received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that all data has been read successfully or that an error response has been received.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_read_characteristic_value(connection, characteristic)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_read_characteristic_value(uint8 connection, uint16 characteristic);<br><br>/* Response id */<br>dumo_rsp_gatt_read_characteristic_value_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_read_characteristic_value_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_characteristic_value">gatt_characteristic_value</a></td><td>This event contains the data belonging to a characteristic sent by the GATT Server.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_read_characteristic_value_by_uuid"><header >gatt_read_characteristic_value_by_uuid</header><div><p>This command can be used to read the characteristic value of a service from a remote GATT database by giving the UUID of the characteristic and the 
            handle of the service containing this characteristic. A single <a href="#evt_gatt_characteristic_value">
            gatt_characteristic_value</a> event is generated if the length of the characteristic value returned by the 
            remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one 
            <a href="#evt_gatt_characteristic_value">
            gatt_characteristic_value</a> event is generated because the firmware will automatically use the "read long" GATT procedure. 
            A received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that all data has been read successfully or that an error response has been received.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> service</td><td> GATT service handle. This value is normally received from the <a href="#evt_gatt_service">gatt_service</a> event.</td></tr><tr><td>9</td><td> uint8array</td><td> uuid</td><td> Characteristic UUID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_read_characteristic_value_by_uuid(connection, service, uuid_len, uuid_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_read_characteristic_value_by_uuid(uint8 connection, uint32 service, uint8 uuid_len, const uint8 *uuid_data);<br><br>/* Response id */<br>dumo_rsp_gatt_read_characteristic_value_by_uuid_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_read_characteristic_value_by_uuid_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_characteristic_value">gatt_characteristic_value</a></td><td>This event contains the data belonging to a characteristic sent by the GATT Server.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_read_descriptor_value"><header >gatt_read_descriptor_value</header><div><p>This command can be used to read the descriptor value of a characteristic in a remote GATT database. A single <a href="#evt_gatt_descriptor_value">
            gatt_descriptor_value</a> event is  generated if the length of the descriptor value returned by the remote GATT server is less than or equal to the size of the 
            GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one <a href="#evt_gatt_descriptor_value">gatt_descriptor_value</a> event is generated because the firmware 
            will automatically use the "read long" GATT procedure. A received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that all 
            data has been read successfully or that an error response has been received.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0e </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> descriptor</td><td> The handle of the GATT characteristic descriptor</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0e </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_read_descriptor_value(connection, descriptor)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_read_descriptor_value(uint8 connection, uint16 descriptor);<br><br>/* Response id */<br>dumo_rsp_gatt_read_descriptor_value_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_read_descriptor_value_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_descriptor_value">gatt_descriptor_value</a></td><td>Descriptor value received from the remote GATT server.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_read_multiple_characteristic_values"><header >gatt_read_multiple_characteristic_values</header><div><p>This command can be used to read the values of multiple characteristics from a remote GATT database at once. 
            <a href="#evt_gatt_characteristic_value">gatt_characteristic_value</a> events are generated as the values are returned by the remote GATT server.
            A received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that either all data has been read successfully or that an error response has been received.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x11 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5</td><td> uint8array</td><td> characteristic_list</td><td> Little endian encoded uint16 list of characteristics to be read.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x11 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_read_multiple_characteristic_values(connection, characteristic_list_len, characteristic_list_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_read_multiple_characteristic_values(uint8 connection, uint8 characteristic_list_len, const uint8 *characteristic_list_data);<br><br>/* Response id */<br>dumo_rsp_gatt_read_multiple_characteristic_values_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_read_multiple_characteristic_values_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_characteristic_value">gatt_characteristic_value</a></td><td>This event contains the data belonging to a characteristic sent by the GATT Server.</td></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_send_characteristic_confirmation"><header >gatt_send_characteristic_confirmation</header><div><p>This command must be used to send a characteristic confirmation to a remote GATT server after receiving an indication. 
            The <a href="#evt_gatt_characteristic_value">gatt_characteristic_value_event</a> carries the att_opcode containing handle_value_indication (0x1e) which reveals 
            that an indication has been received and this must be confirmed with this command. Confirmation needs to be sent within 30 seconds, otherwise the GATT transactions 
            between the client and the server are discontinued.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0d </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0d </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_send_characteristic_confirmation(connection)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_send_characteristic_confirmation(uint8 connection);<br><br>/* Response id */<br>dumo_rsp_gatt_send_characteristic_confirmation_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_send_characteristic_confirmation_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_set_characteristic_notification"><header >gatt_set_characteristic_notification</header><div><p>This command can be used to enable or disable the notifications and indications being sent from a remote GATT server. This procedure discovers a 
            characteristic client configuration descriptor and writes the related configuration flags to a remote GATT database. A received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event
            indicates that this GATT procedure has successfully completed or that is has failed with an error.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_gatt_client_config_flag">flags</a></td><td> Characteristic client configuration flags</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_set_characteristic_notification(connection, characteristic, <a href="#enum_gatt_client_config_flag">flags</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_set_characteristic_notification(uint8 connection, uint16 characteristic, <a href="#enum_gatt_client_config_flag">uint8 flags</a>);<br><br>/* Response id */<br>dumo_rsp_gatt_set_characteristic_notification_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_set_characteristic_notification_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr><tr><td><a href="#evt_gatt_characteristic_value">gatt_characteristic_value</a></td><td>If an indication or notification has been enabled for a characteristic, this event is triggered 
                whenever an indication or notification is sent by the remote GATT server. The triggering conditions on the GATT server side are defined by an
                upper level, for example by a profile; <b>so it is possible that no values are ever received, or that it may take time, depending on how the server is configured.</b></td></tr></table></div></div><div class="command" id="cmd_gatt_set_max_mtu"><header >gatt_set_max_mtu</header><div><p>This command can be used to set the maximum number of GATT Message Transfer Units (MTU).
             If max_mtu is non-default, MTU is exchanged automatically after Bluetooth LE connection has been established. 
             </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> max_mtu</td><td> Maximum number of Message Transfer Units (MTU) allowed<ul><li>
                Range:  23 to 158</li></ul>Default: 23</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_set_max_mtu(max_mtu)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_set_max_mtu(uint16 max_mtu);<br><br>/* Response id */<br>dumo_rsp_gatt_set_max_mtu_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_set_max_mtu_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_write_characteristic_value"><header >gatt_write_characteristic_value</header><div><p>This command can be used to write the value of a characteristic in a remote GATT database. If the length of the given value is greater than 
            the exchanged GATT MTU (Message Transfer Unit), "write long" GATT procedure is used automatically. Received 
            <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> event indicates that all data has been written successfully or that an error response 
            has been received.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8array</td><td> value</td><td> Characteristic value</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_write_characteristic_value(connection, characteristic, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_write_characteristic_value(uint8 connection, uint16 characteristic, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_write_characteristic_value_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_write_characteristic_value_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div><div class="command" id="cmd_gatt_write_characteristic_value_without_response"><header >gatt_write_characteristic_value_without_response</header><div><p>This command can be used to write the value of a characteristic in a
            remote GATT database. This command does not generate any event. All failures on the server are ignored silently. 
            For example, if an error is generated in the remote GATT server and the given value is not written into database no error message will be reported to the local 
            GATT client. Note that this command cannot be used to write long values.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8array</td><td> value</td><td> Characteristic value</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_write_characteristic_value_without_response(connection, characteristic, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_write_characteristic_value_without_response(uint8 connection, uint16 characteristic, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_write_characteristic_value_without_response_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_write_characteristic_value_without_response_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_write_descriptor_value"><header >gatt_write_descriptor_value</header><div><p>This command can be used to write the value of a characteristic descriptor in a remote GATT database. If the length of the given value is greater 
            than the exchanged GATT MTU size, "write long" GATT procedure is used automatically. Received <a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a> 
            event indicates that all data has been written succesfully or that an error response has been received.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0f </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> descriptor</td><td> The handle of the GATT characteristic descriptor</td></tr><tr><td>7</td><td> uint8array</td><td> value</td><td> Descriptor value</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x0f </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_write_descriptor_value(connection, descriptor, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_write_descriptor_value(uint8 connection, uint16 descriptor, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_write_descriptor_value_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_write_descriptor_value_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_gatt_procedure_completed">gatt_procedure_completed</a></td><td>Procedure has been successfully completed or failed with error.</td></tr></table></div></div></div><div class="msg_type"><header>gatt events</header><div class="event" id="evt_gatt_service"><header >gatt_service</header><div><p>This event indicates that a GATT service in the remote GATT database was discovered. This event is generated after issuing either the 
            <a href="#cmd_gatt_discover_primary_services">gatt_discover_primary_services</a> or <a href="#cmd_gatt_discover_primary_services_by_uuid">
            gatt_discover_primary_services_by_uuid</a> command.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> service</td><td> GATT service handle</td></tr><tr><td>9</td><td> uint8array</td><td> uuid</td><td> Characteristic UUID, first byte is the length of UUID and rest is UUID in little-endian format</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_service(connection, service, uuid_len, uuid_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_service_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_service_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint32 service,<br>&nbsp;&nbsp;uint8array uuid<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_characteristic"><header >gatt_characteristic</header><div><p>This event indicates that a GATT characteristic in the remote GATT database was discovered. This event is generated after issuing either the <a href="#cmd_gatt_discover_characteristics">
            gatt_discover_characteristics</a> or <a href="#cmd_gatt_discover_characteristics_by_uuid">gatt_discover_characteristics_by_uuid</a> command.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle</td></tr><tr><td>7</td><td> uint8</td><td> properties</td><td> Characteristic properties as a bitmask:
                <ul>
                <li><b>0x01:</b> broadcast permitted</dd>
                <li><b>0x02:</b> read permitted</dd>
                <li><b>0x04:</b> write without response permitted</dd>
                <li><b>0x08:</b> write permitted</dd>
                <li><b>0x10:</b> notifications permitted</dd>
                <li><b>0x20:</b> indications permitted</dd>
                <li><b>0x40:</b> signed writes permitted</dd>
                <li><b>0x80:</b> characteristic has extended properties</dd>
                </ul>
                Consult the GATT specification for more details.
                </td></tr><tr><td>8</td><td> uint8array</td><td> uuid</td><td> Characteristic UUID, first byte is the length of UUID and rest is UUID in little-endian format</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_characteristic(connection, characteristic, properties, uuid_len, uuid_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_characteristic_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_characteristic_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 characteristic,<br>&nbsp;&nbsp;uint8 properties,<br>&nbsp;&nbsp;uint8array uuid<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_descriptor"><header >gatt_descriptor</header><div><p>This event indicates that a GATT characteristic descriptor in the remote GATT database was discovered. This event is generated after issuing the 
            <a href="#cmd_gatt_discover_descriptors">gatt_discover_descriptors</a> command.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> descriptor</td><td> The handle of the GATT characteristic descriptor</td></tr><tr><td>7</td><td> uint8array</td><td> uuid</td><td> Characteristic UUID, first byte is the length of UUID and rest is UUID in little-endian format</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_descriptor(connection, descriptor, uuid_len, uuid_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_descriptor_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_descriptor_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 descriptor,<br>&nbsp;&nbsp;uint8array uuid<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_characteristic_value"><header >gatt_characteristic_value</header><div><p>This event indicates that the value of a characteristic in the remote GATT server was received. This event is triggered as a result of several commands: <a href="#cmd_gatt_read_characteristic_value">gatt_read_characteristic_value</a>, <a href="#cmd_gatt_read_characteristic_value_by_uuid"> gatt_read_characteristic_value_by_uuid</a>, <a href="#cmd_gatt_read_multiple_characteristic_values">gatt_read_multiple_characteristic_values</a>, <a href="#cmd_gatt_prepare_characteristic_value_write">gatt_prepare_characteristic_value_write</a>; and when the remote GATT server sends indications or notifications after enabling notifications with <a href="#cmd_gatt_set_characteristic_notification">gatt_set_characteristic_notification</a>. 
            The parameter att_opcode reveals which type of GATT transaction triggered this event. 
            In particular, if the att_opcode type is handle_value_indication (0x1d), the application needs to confirm the indication with 
            <a href="#cmd_gatt_send_characteristic_confirmation">gatt_send_characteristic_confirmation</a>.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_gatt_att_opcode">att_opcode</a></td><td> Attribute opcode which informs the GATT transaction used</td></tr><tr><td>8-9</td><td> uint16</td><td> offset</td><td> Value offset</td></tr><tr><td>10</td><td> uint8array</td><td> value</td><td> Characteristic value</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_characteristic_value(connection, characteristic, att_opcode, offset, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_characteristic_value_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_characteristic_value_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 characteristic,<br>&nbsp;&nbsp;<a href="#enum_gatt_att_opcode">uint8 att_opcode</a>,<br>&nbsp;&nbsp;uint16 offset,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_descriptor_value"><header >gatt_descriptor_value</header><div><p>This event indicates that the value of a descriptor in the remote GATT server was received. This event is generated by the 
            <a href="#cmd_gatt_read_descriptor_value">gatt_read_descriptor_value</a> command.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> descriptor</td><td> The handle of the GATT characteristic descriptor</td></tr><tr><td>7-8</td><td> uint16</td><td> offset</td><td> Value offset</td></tr><tr><td>9</td><td> uint8array</td><td> value</td><td> Descriptor value</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_descriptor_value(connection, descriptor, offset, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_descriptor_value_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_descriptor_value_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 descriptor,<br>&nbsp;&nbsp;uint16 offset,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_procedure_completed"><header >gatt_procedure_completed</header><div><p>This event indicates that the current GATT procedure has been completed successfully or that is has failed with an error. All GATT commands excluding
            <a href="#cmd_gatt_write_characteristic_value_without_response">gatt_write_characteristic_value_without_response</a> and <a href="#cmd_gatt_send_characteristic_confirmation">
            gatt_send_characteristic_confirmation</a> will trigger this event, so the application must wait for this event before issuing another GATT command (excluding the
            two aforementioned exceptions).</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x09 </td><td>class</td><td>Message class:Generic Attribute Profile</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_procedure_completed(connection, result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_procedure_completed_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_procedure_completed_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>gatt enumerations</header><div class="enum" id="enum_gatt_att_opcode"><header>gatt_att_opcode</header><div><p>These values indicate which attribute request or response has caused the event.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>8</td><td>gatt_read_by_type_request</td><td>Read by type request</td></tr><tr><td>9</td><td>gatt_read_by_type_response</td><td>Read by type response</td></tr><tr><td>10</td><td>gatt_read_request</td><td>Read request</td></tr><tr><td>11</td><td>gatt_read_response</td><td>Read response</td></tr><tr><td>12</td><td>gatt_read_blob_request</td><td>Read blob request</td></tr><tr><td>13</td><td>gatt_read_blob_response</td><td>Read blob response</td></tr><tr><td>14</td><td>gatt_read_multiple_request</td><td>Read multiple request</td></tr><tr><td>15</td><td>gatt_read_multiple_response</td><td>Read multiple response</td></tr><tr><td>18</td><td>gatt_write_request</td><td>Write request</td></tr><tr><td>19</td><td>gatt_write_response</td><td>Write response</td></tr><tr><td>82</td><td>gatt_write_command</td><td>Write command</td></tr><tr><td>22</td><td>gatt_prepare_write_request</td><td>Prepare write request</td></tr><tr><td>23</td><td>gatt_prepare_write_response</td><td>Prepare write response</td></tr><tr><td>24</td><td>gatt_execute_write_request</td><td>Execute write request</td></tr><tr><td>25</td><td>gatt_execute_write_response</td><td>Execute write response</td></tr><tr><td>27</td><td>gatt_handle_value_notification</td><td>Notification</td></tr><tr><td>29</td><td>gatt_handle_value_indication</td><td>Indication</td></tr></table></div></div><div class="enum" id="enum_gatt_client_config_flag"><header>gatt_client_config_flag</header><div><p>These values define whether the client is to receive notifications or indications from a remote GATT server.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>gatt_disable</td><td>Disable notifications and indications</td></tr><tr><td>1</td><td>gatt_notification</td><td>Notification</td></tr><tr><td>2</td><td>gatt_indication</td><td>Indication</td></tr></table></div></div><div class="enum" id="enum_gatt_execute_write_flag"><header>gatt_execute_write_flag</header><div><p>These values define whether the GATT server is to cancel all queued writes or commit all queued writes to a remote database.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>gatt_cancel</td><td>Cancel all queued writes</td></tr><tr><td>1</td><td>gatt_commit</td><td>Commit all queued writes</td></tr></table></div></div></div></div><div class="cls" id="cls_gatt_server"><header>Generic Attribute Profile Server (gatt_server)</header>These commands and events are used by the local GATT server to manage the local GATT database.<div class="msg_type"><header>gatt_server commands</header><div class="command" id="cmd_gatt_server_read_attribute_type"><header >gatt_server_read_attribute_type</header><div><p>This command can be used to read the type of an attribute from a local GATT database. The type is a UUID, usually 16 or 128 bits long.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> attribute</td><td> Attribute handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8array</td><td> type</td><td> Variable length byte array. First byte is the length of the array.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_server_read_attribute_type(attribute)(result, type_len, type_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_server_read_attribute_type(uint16 attribute);<br><br>/* Response id */<br>dumo_rsp_gatt_server_read_attribute_type_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_server_read_attribute_type_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8array type<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_server_read_attribute_value"><header >gatt_server_read_attribute_value</header><div><p>This command can be used to read the value of an attribute from a local GATT database.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> attribute</td><td> Attribute handle</td></tr><tr><td>6-7</td><td> uint16</td><td> offset</td><td> Value offset</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8array</td><td> value</td><td> Variable length byte array. First byte is the length of the array.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_server_read_attribute_value(attribute, offset)(result, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_server_read_attribute_value(uint16 attribute, uint16 offset);<br><br>/* Response id */<br>dumo_rsp_gatt_server_read_attribute_value_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_server_read_attribute_value_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_server_send_characteristic_notification"><header >gatt_server_send_characteristic_notification</header><div><p>This command can be used to send notifications or indications to a remote GATT client. Notification or indication is sent only if the client has enabled 
            them by setting the corresponding flag to the Client Characteristic Configuration descriptor. A new indication cannot be sent before a confirmation 
            from the GATT client is first received. The confirmation is indicated by <a href="#evt_gatt_server_characteristic_status">gatt_server_characteristic_status event</a>.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> 
                    Handle of the connection over which the notification or indication is sent. Values: <ul><li><b>0xff: </b>Sends notification or indication to all connected devices.</li><li><b>Other: </b>Connection handle</li></ul>
                </td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> Characteristic handle</td></tr><tr><td>7</td><td> uint8array</td><td> value</td><td> Value to be notified or indicated</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_server_send_characteristic_notification(connection, characteristic, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_server_send_characteristic_notification(uint8 connection, uint16 characteristic, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_server_send_characteristic_notification_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_server_send_characteristic_notification_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_server_send_user_read_response"><header >gatt_server_send_user_read_response</header><div><p>This command must be used to send a response to a <a href="#evt_gatt_server_user_read_request">user_read_request</a> event. The response needs to be sent within 30 second, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the characteristic value is sent to the remote GATT client in the normal way. Other attr_errorcode 
            values will cause the local GATT server to send an attribute protocol error response instead of the actual data.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> att_errorcode</td><td> Attribute protocol error code. Values:<ul><li><b>0: </b>No error</li><li>Non-zero: see error codes</li></ul></td></tr><tr><td>8</td><td> uint8array</td><td> value</td><td> Characteristic value to send to the GATT client. Ignored if att_errorcode is not 0.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_server_send_user_read_response(connection, characteristic, att_errorcode, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_server_send_user_read_response(uint8 connection, uint16 characteristic, uint8 att_errorcode, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_server_send_user_read_response_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_server_send_user_read_response_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_server_send_user_write_response"><header >gatt_server_send_user_write_response</header><div><p>This command must be used to send a response to a <a href="#evt_gatt_server_user_write_request">gatt_server_user_write_request</a> event. The response needs to be sent within 30 seconds, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the ATT protocol's write response is sent to indicate to the remote GATT client that 
            the write operation was processed successfully. Other values will cause the local GATT server to send an ATT protocol error response.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> att_errorcode</td><td> Attribute protocol error code. Values:<ul><li><b>0: </b>No error</li><li>Non-zero: see error codes</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_server_send_user_write_response(connection, characteristic, att_errorcode)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_server_send_user_write_response(uint8 connection, uint16 characteristic, uint8 att_errorcode);<br><br>/* Response id */<br>dumo_rsp_gatt_server_send_user_write_response_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_server_send_user_write_response_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_gatt_server_write_attribute_value"><header >gatt_server_write_attribute_value</header><div><p>This command can be used to write the value of an attribute in the local GATT database. Writing the value of a characteristic of the local GATT database 
            will not trigger notifications or indications to the remote GATT client in case such characteristic has property of indicate or notify and the client has enabled 
            notification or indication. Notifications and indications are sent to the remote GATT client using <a href="#cmd_gatt_server_send_characteristic_notification">
            gatt_server_send_characteristic_notification</a> command.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> attribute</td><td>  Attribute handle</td></tr><tr><td>6-7</td><td> uint16</td><td> offset</td><td> Value offset</td></tr><tr><td>8</td><td> uint8array</td><td> value</td><td> Value</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call gatt_server_write_attribute_value(attribute, offset, value_len, value_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_gatt_server_write_attribute_value(uint16 attribute, uint16 offset, uint8 value_len, const uint8 *value_data);<br><br>/* Response id */<br>dumo_rsp_gatt_server_write_attribute_value_id<br><br>/* Response structure */<br>struct dumo_msg_gatt_server_write_attribute_value_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>gatt_server events</header><div class="event" id="evt_gatt_server_attribute_value"><header >gatt_server_attribute_value</header><div><p>This event indicates that the value of an attribute in the local GATT database has been changed by a remote GATT client. Parameter att_opcode 
            describes which GATT procedure was used to change the value.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> attribute</td><td> Attribute Handle</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_gatt_att_opcode">att_opcode</a></td><td> Attribute opcode which informs the procedure from which attribute the value was received</td></tr><tr><td>8-9</td><td> uint16</td><td> offset</td><td> Value offset</td></tr><tr><td>10</td><td> uint8array</td><td> value</td><td> Value</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_server_attribute_value(connection, attribute, att_opcode, offset, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_server_attribute_value_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_server_attribute_value_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 attribute,<br>&nbsp;&nbsp;<a href="#enum_gatt_att_opcode">uint8 att_opcode</a>,<br>&nbsp;&nbsp;uint16 offset,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_server_user_read_request"><header >gatt_server_user_read_request</header><div><p>This event indicates that a remote GATT client is attempting to read a value of an attribute from the local GATT database, 
            where the attribute was defined in the GATT XML firmware configuration file to have type="user". Parameter att_opcode informs which GATT 
            procedure was used to read the value. The application needs to respond to this request by using the <a href="#cmd_gatt_server_send_user_read_response">
            gatt_server_send_user_read_response</a> command within 30 seconds, otherwise this GATT connection is dropped by remote side.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_gatt_att_opcode">att_opcode</a></td><td> Attribute opcode which informs the procedure from which attribute the value was received</td></tr><tr><td>8-9</td><td> uint16</td><td> offset</td><td> Value offset</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_server_user_read_request(connection, characteristic, att_opcode, offset)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_server_user_read_request_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_server_user_read_request_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 characteristic,<br>&nbsp;&nbsp;<a href="#enum_gatt_att_opcode">uint8 att_opcode</a>,<br>&nbsp;&nbsp;uint16 offset<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_server_user_write_request"><header >gatt_server_user_write_request</header><div><p>This event indicates that a remote GATT client is attempting to write a value of  an attribute in to the local GATT database, where the attribute 
            was defined in the GATT XML firmware configuration file to have type="user". Parameter att_opcode informs which attribute procedure was used to write the value. 
            The application needs to respond to this request by using the <a href="#cmd_gatt_server_send_user_write_response">gatt_server_send_user_write_response</a> command 
            within 30 seconds, otherwise this GATT connection is dropped by the remote side.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_gatt_att_opcode">att_opcode</a></td><td> Attribute opcode which informs the procedure from which attribute the value was received</td></tr><tr><td>8-9</td><td> uint16</td><td> offset</td><td> Value offset</td></tr><tr><td>10</td><td> uint8array</td><td> value</td><td> Value</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_server_user_write_request(connection, characteristic, att_opcode, offset, value_len, value_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_server_user_write_request_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_server_user_write_request_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 characteristic,<br>&nbsp;&nbsp;<a href="#enum_gatt_att_opcode">uint8 att_opcode</a>,<br>&nbsp;&nbsp;uint16 offset,<br>&nbsp;&nbsp;uint8array value<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_gatt_server_characteristic_status"><header >gatt_server_characteristic_status</header><div><p>This event indicates either that a local Client Characteristic Configuration descriptor has been changed by the remote GATT client, or that a confirmation 
            from the remote GATT client was received upon a successful reception of the indication. Confirmation by the remote GATT client should be received within 30 seconds 
            after an indication has been sent with the <a href="#cmd_gatt_server_send_characteristic_notification">gatt_server_send_characteristic_notification</a> command, otherwise 
            further GATT transactions over this connection are disabled by the stack.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0a </td><td>class</td><td>Message class:Generic Attribute Profile Server</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> characteristic</td><td> GATT characteristic handle. This value is normally received from the gatt_characteristic event</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_gatt_server_characteristic_status_flag">status_flags</a></td><td> Describes whether Client Characteristic Configuration was changed or if confirmation was received.</td></tr><tr><td>8-9</td><td> uint16</td><td> <a href="#enum_gatt_client_config_flag">client_config_flags</a></td><td> 
                This field carries the new value of the Client Characteristic Configuration. If the status_flags is 0x2 (confirmation received), the value of this field can be ignored.
                </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event gatt_server_characteristic_status(connection, characteristic, status_flags, client_config_flags)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_gatt_server_characteristic_status_id<br><br>/* event structure*/<br>struct dumo_msg_gatt_server_characteristic_status_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 characteristic,<br>&nbsp;&nbsp;<a href="#enum_gatt_server_characteristic_status_flag">uint8 status_flags</a>,<br>&nbsp;&nbsp;<a href="#enum_gatt_client_config_flag">uint16 client_config_flags</a><br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>gatt_server enumerations</header><div class="enum" id="enum_gatt_server_characteristic_status_flag"><header>gatt_server_characteristic_status_flag</header><div><p>These values describe whether characteristic client configuration was changed or whether a characteristic confirmation was received.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>1</td><td>gatt_server_client_config</td><td>Characteristic client configuration has been changed.</td></tr><tr><td>2</td><td>gatt_server_confirmation</td><td>Characteristic confirmation has been received.</td></tr></table></div></div></div></div><div class="cls" id="cls_hardware"><header>Hardware (hardware)</header>The commands and events in this class can be used to access and configure the system hardware and peripherals.<div class="msg_type"><header>hardware commands</header><div class="command" id="cmd_hardware_configure_gpio"><header >hardware_configure_gpio</header><div><p>This command can be used to configure the mode of an I/O port. After a boot, the module uses the default settings defined in hardware.xml, and this command can used to override the default settings. 
            Note that GPIO configurations set with this command do not persist over a reset.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> port</td><td> Port index, where A=0, B=1.</td></tr><tr><td>5-6</td><td> uint16</td><td> gpio</td><td> Index of the GPIO pin on the port which this command affects.</td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_hardware_gpio_mode">mode</a></td><td> Pin mode</td></tr><tr><td>8</td><td> uint8</td><td> <a href="#enum_hardware_gpio_configuration">pullup</a></td><td> Pin configuration</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_configure_gpio(port, gpio, <a href="#enum_hardware_gpio_mode">mode</a>, <a href="#enum_hardware_gpio_configuration">pullup</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_configure_gpio(uint8 port, uint16 gpio, <a href="#enum_hardware_gpio_mode">uint8 mode</a>, <a href="#enum_hardware_gpio_configuration">uint8 pullup</a>);<br><br>/* Response id */<br>dumo_rsp_hardware_configure_gpio_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_configure_gpio_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_read_adc"><header >hardware_read_adc</header><div><p>This command can be used to read the specified channel of the A/D converter in the module. Note that the ADC channels must be configured
            in the hardware.xml file, as described in the module Configuration Guide. Note that only channels 4 through 7 are connected, Data read from channels 0 to 3 will be undefined.<br>
            ADC value of 4095 corresponds to the input being at Vdd, value of which can be obtained with 
            <a href="#cmd_hardware_read_vdd">read vdd command</a>
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> input</td><td> ADC input channel. Value range: 4-7.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> input</td><td> ADC input channel. Value range: 4-7.</td></tr><tr><td>7-8</td><td> uint16</td><td> value</td><td> ADC value</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_read_adc(input)(result, input, value)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_read_adc(uint8 input);<br><br>/* Response id */<br>dumo_rsp_hardware_read_adc_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_read_adc_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 input,<br>&nbsp;&nbsp;uint16 value<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_read_gpio"><header >hardware_read_gpio</header><div><p>This command can be used to read the pins of the specified I/O-port of the module.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> port</td><td> Port index to read from, A=0, B=1.</td></tr><tr><td>5-6</td><td> uint16</td><td> mask</td><td> Bitmask of which pins on the port should be read</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-7</td><td> uint16</td><td> data</td><td> Port data</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_read_gpio(port, mask)(result, data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_read_gpio(uint8 port, uint16 mask);<br><br>/* Response id */<br>dumo_rsp_hardware_read_gpio_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_read_gpio_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint16 data<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_read_i2c"><header >hardware_read_i2c</header><div><p>This command can be used to read from the specified I2C interface. The I2C interfaces must be configured in the hardware.xml file, as described in the
            module Configuration Guide.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> channel</td><td> I2C channel to use. Value range: 0-1</td></tr><tr><td>5-6</td><td> uint16</td><td> slave_address</td><td> Slave address to use</td></tr><tr><td>7</td><td> uint8</td><td> length</td><td> Amount of data to read</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8array</td><td> data</td><td> Data that was read if command was successful</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_read_i2c(channel, slave_address, length)(result, data_len, data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_read_i2c(uint8 channel, uint16 slave_address, uint8 length);<br><br>/* Response id */<br>dumo_rsp_hardware_read_i2c_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_read_i2c_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8array data<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_read_junction_temperature"><header >hardware_read_junction_temperature</header><div><p>This command can be used to read the junction temperature of the module's MCU. 
            Command is active only if the ADC is active. For more information, see the Hardware
             Configuration Guide.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-7</td><td> uint16</td><td> value</td><td> Junction temperature in Celsius</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_read_junction_temperature()(result, value)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_read_junction_temperature();<br><br>/* Response id */<br>dumo_rsp_hardware_read_junction_temperature_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_read_junction_temperature_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint16 value<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_read_vdd"><header >hardware_read_vdd</header><div><p>This command can be used to read the voltage level of the Vdd pin. This command is active only if the ADC is active. For more information see the Hardware Configuration Guide.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-7</td><td> uint16</td><td> value</td><td> Voltage of Vdd in millivolts</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_read_vdd()(result, value)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_read_vdd();<br><br>/* Response id */<br>dumo_rsp_hardware_read_vdd_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_read_vdd_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint16 value<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_read_write_spi"><header >hardware_read_write_spi</header><div><p>
            This command can be used to read from and write to the specified SPI interface. 
            The SPI interfaces must be configured in the hardware.xml file, as described in the 
            module Configuration Guide.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> channel</td><td> SPI channel to use. Value range: 1-2</td></tr><tr><td>5</td><td> uint8</td><td> cs_port</td><td> Chip select pin port. Value range: 0 (A) or 1 (B)</td></tr><tr><td>6</td><td> uint8</td><td> cs_pin</td><td> Chip select pin. Value range: 1-15 or 0 to disable. </td></tr><tr><td>7</td><td> uint8</td><td> <a href="#enum_hardware_uartparity">cs_polarity</a></td><td> 
                    Chip select pin polarity.
                    </td></tr><tr><td>8</td><td> uint8</td><td> read_length</td><td> Amount of data to read and write.
                    <br><br>
                    Note: SPI read and write are synchronous and you will receive at least as many bytes
                    as you have written. If you reading more than writing then the writing will be zero padded
                    to match the length of the data to read. 
                    </td></tr><tr><td>9</td><td> uint8array</td><td> data</td><td> Data to write</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8array</td><td> data</td><td> Data that was read if command was successful</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_read_write_spi(channel, cs_port, cs_pin, <a href="#enum_hardware_uartparity">cs_polarity</a>, read_length, data_len, data_data)(result, data_len, data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_read_write_spi(uint8 channel, uint8 cs_port, uint8 cs_pin, <a href="#enum_hardware_uartparity">uint8 cs_polarity</a>, uint8 read_length, uint8 data_len, const uint8 *data_data);<br><br>/* Response id */<br>dumo_rsp_hardware_read_write_spi_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_read_write_spi_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8array data<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_set_soft_timer"><header >hardware_set_soft_timer</header><div><p>This command can be used to start a software timer. Multiple concurrent timers can be running simultaneously. There are 256 unique timer ID's available,
            but in practice the amount of concurrent timers is limited by the amount of free memory.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> time</td><td> Interval between how often to send events, in milliseconds. If time is 0, removes the scheduled timer.
                The maximum value is 4294967295, which corresponds to about 49.7 days.</td></tr><tr><td>8</td><td> uint8</td><td> timer_id</td><td> Handle that is returned with event</td></tr><tr><td>9</td><td> uint8</td><td> single_shot</td><td> 
                Timer mode. Values: <ul><li><b>0: </b>false (timer is repeating)</li><li><b>1: </b>true (timer runs only once)</li></ul>
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_set_soft_timer(time, timer_id, single_shot)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_set_soft_timer(uint32 time, uint8 timer_id, uint8 single_shot);<br><br>/* Response id */<br>dumo_rsp_hardware_set_soft_timer_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_set_soft_timer_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_hardware_soft_timer">hardware_soft_timer</a></td><td>Sent after specified interval</td></tr></table></div></div><div class="command" id="cmd_hardware_set_uart_configuration"><header >hardware_set_uart_configuration</header><div><p>This command can be used to reconfigure the UART interface. The new configuration will become effective after a 100 ms delay from issuing the command. The response to the command will be sent before the 100 ms delay has elapsed using the original UART parameters. Any new configuration parameter is lost after reset and the firmware default parameters will be used again.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> Endpoint. Must be 0.</td></tr><tr><td>5-8</td><td> uint32</td><td> rate</td><td> UART baud rate. Range: 9600 to 4000000</td></tr><tr><td>9</td><td> uint8</td><td> data_bits</td><td> Data bits. Must be 8.</td></tr><tr><td>10</td><td> uint8</td><td> stop_bits</td><td> Stop bits. Values:<ul><li><b>1: </b>1 stop bit</li><li><b>2: </b>2 stop bits</li></ul></td></tr><tr><td>11</td><td> uint8</td><td> <a href="#enum_hardware_uartparity">parity</a></td><td> Parity bit. Values: see link</td></tr><tr><td>12</td><td> uint8</td><td> flow_ctrl</td><td> UART flow control. Values: <ul><li><b>0: </b>None</li><li><b>1: </b>RTS/CTS</li></ul> </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_set_uart_configuration(endpoint, rate, data_bits, stop_bits, <a href="#enum_hardware_uartparity">parity</a>, flow_ctrl)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_set_uart_configuration(uint8 endpoint, uint32 rate, uint8 data_bits, uint8 stop_bits, <a href="#enum_hardware_uartparity">uint8 parity</a>, uint8 flow_ctrl);<br><br>/* Response id */<br>dumo_rsp_hardware_set_uart_configuration_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_set_uart_configuration_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_stop_i2c"><header >hardware_stop_i2c</header><div><p>This command can be used to stop I2C transmission.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> channel</td><td> I2C channel to use.</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_stop_i2c(channel)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_stop_i2c(uint8 channel);<br><br>/* Response id */<br>dumo_rsp_hardware_stop_i2c_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_stop_i2c_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_write_gpio"><header >hardware_write_gpio</header><div><p>This command can be used to set the logic states of pins of the specified I/O-port using a bitmask.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> port</td><td> Port index, where A=0, B=1.</td></tr><tr><td>5-6</td><td> uint16</td><td> mask</td><td> Bitmask which determines the pins this command is used to set</td></tr><tr><td>7-8</td><td> uint16</td><td> data</td><td> Bitmask of which pins to set high and which pins to set low (1 is high, 0 is low)</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_write_gpio(port, mask, data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_write_gpio(uint8 port, uint16 mask, uint16 data);<br><br>/* Response id */<br>dumo_rsp_hardware_write_gpio_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_write_gpio_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_hardware_write_i2c"><header >hardware_write_i2c</header><div><p>This command can be used to write data into I2C interface. The I2C interfaces must be configured in the hardware.xml file, as described in the
            module Configuration Guide.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> channel</td><td> I2C channel to use. Value range: 0-1</td></tr><tr><td>5-6</td><td> uint16</td><td> slave_address</td><td> Slave address to use</td></tr><tr><td>7</td><td> uint8array</td><td> data</td><td> Data to write</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call hardware_write_i2c(channel, slave_address, data_len, data_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_hardware_write_i2c(uint8 channel, uint16 slave_address, uint8 data_len, const uint8 *data_data);<br><br>/* Response id */<br>dumo_rsp_hardware_write_i2c_id<br><br>/* Response structure */<br>struct dumo_msg_hardware_write_i2c_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>hardware events</header><div class="event" id="evt_hardware_soft_timer"><header >hardware_soft_timer</header><div><p>This event indicates that the soft timer has lapsed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> timer_id</td><td> Timer handle</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event hardware_soft_timer(timer_id)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_hardware_soft_timer_id<br><br>/* event structure*/<br>struct dumo_msg_hardware_soft_timer_evt_t<br>{<br>&nbsp;&nbsp;uint8 timer_id<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_hardware_interrupt"><header >hardware_interrupt</header><div><p>This event indicates that an external interrupt has occurred and provides a timestamp and a mask which indicates all triggered  interrupt channels.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0c </td><td>class</td><td>Message class:Hardware</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> interrupts</td><td> Mask of interrupt channels</td></tr><tr><td>6-9</td><td> uint32</td><td> timestamp</td><td> Timestamp</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event hardware_interrupt(interrupts, timestamp)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_hardware_interrupt_id<br><br>/* event structure*/<br>struct dumo_msg_hardware_interrupt_evt_t<br>{<br>&nbsp;&nbsp;uint16 interrupts,<br>&nbsp;&nbsp;uint32 timestamp<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>hardware enumerations</header><div class="enum" id="enum_hardware_gpio_configuration"><header>hardware_gpio_configuration</header><div><p>These values define whether the pin is used in pull-up, pull-down or in no pull-up and no pull-down mode.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>hardware_gpio_float</td><td>No pull-up, no pull-down</td></tr><tr><td>1</td><td>hardware_gpio_pullup</td><td>Pull-up</td></tr><tr><td>2</td><td>hardware_gpio_pulldown</td><td>Pull-down</td></tr></table></div></div><div class="enum" id="enum_hardware_gpio_mode"><header>hardware_gpio_mode</header><div><p>These values define whether the pin is used as an input, an output, as a function pin or as an analog signal pin.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>hardware_gpio_input</td><td>Input</td></tr><tr><td>1</td><td>hardware_gpio_output</td><td>Output</td></tr><tr><td>2</td><td>hardware_gpio_function</td><td>Function</td></tr><tr><td>3</td><td>hardware_gpio_analog</td><td>Analog</td></tr></table></div></div><div class="enum" id="enum_hardware_uartparity"><header>hardware_uartparity</header><div><p>These values define the parity bit configuration of the related UART connection.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>hardware_none</td><td>None </td></tr><tr><td>1</td><td>hardware_odd</td><td>Odd parity</td></tr><tr><td>2</td><td>hardware_even</td><td>Even parity </td></tr></table></div></div><div class="enum" id="enum_hardware_cspolarity"><header>hardware_cspolarity</header><div><p>These values define the polarity of a Chip Select pin.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>hardware_low</td><td>Active low</td></tr><tr><td>1</td><td>hardware_high</td><td>Active high</td></tr><tr><td>2</td><td>hardware_opendrain</td><td>Open drain (active low). Use when using external pullup resistor.</td></tr></table></div></div></div></div><div class="cls" id="cls_identity"><header>Identity Profile (identity)</header>The commands and events in this class are related to Bluetooth Classic Identity Profile operations.<div class="msg_type"><header>identity commands</header><div class="command" id="cmd_identity_local_identity"><header >identity_local_identity</header><div><p>This command can be used to read Identity Profile information from the local device.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x0b </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-7</td><td> uint16</td><td> source</td><td> The authority who has issued the Vendor ID. Values:<ul><li><b>1: </b>Bluetooth SIG</li><li><b>0x0002: </b>USB IF</li></ul></td></tr><tr><td>8-9</td><td> uint16</td><td> vendor</td><td> Vendor ID</td></tr><tr><td>10-11</td><td> uint16</td><td> product</td><td> Product ID</td></tr><tr><td>12-13</td><td> uint16</td><td> version</td><td> Version ID</td></tr><tr><td>14</td><td> uint8array</td><td> description</td><td> Service Description</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call identity_local_identity()(result, source, vendor, product, version, description_len, description_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_identity_local_identity();<br><br>/* Response id */<br>dumo_rsp_identity_local_identity_id<br><br>/* Response structure */<br>struct dumo_msg_identity_local_identity_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint16 source,<br>&nbsp;&nbsp;uint16 vendor,<br>&nbsp;&nbsp;uint16 product,<br>&nbsp;&nbsp;uint16 version,<br>&nbsp;&nbsp;uint8array description<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_identity_modify_local_identity"><header >identity_modify_local_identity</header><div><p>This command can be used to modify some fields in the local identity profile.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> vendor</td><td> Vendor ID.</td></tr><tr><td>6-7</td><td> uint16</td><td> product</td><td> Product ID</td></tr><tr><td>8-9</td><td> uint16</td><td> version</td><td> Version ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call identity_modify_local_identity(vendor, product, version)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_identity_modify_local_identity(uint16 vendor, uint16 product, uint16 version);<br><br>/* Response id */<br>dumo_rsp_identity_modify_local_identity_id<br><br>/* Response structure */<br>struct dumo_msg_identity_modify_local_identity_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_identity_remote_identity"><header >identity_remote_identity</header><div><p>This command can be used to read Identity Profile information from a remote Bluetooth Classic device.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth Classic address in little endian format</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call identity_remote_identity(address)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_identity_remote_identity(bd_addr *address);<br><br>/* Response id */<br>dumo_rsp_identity_remote_identity_id<br><br>/* Response structure */<br>struct dumo_msg_identity_remote_identity_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_identity_remote_identity">identity_remote_identity</a></td></tr></table></div></div></div><div class="msg_type"><header>identity events</header><div class="event" id="evt_identity_remote_identity"><header >identity_remote_identity</header><div><p>This event indicates the reception of Identity Profile information from a remote Bluetooth Classic device.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x11 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x05 </td><td>class</td><td>Message class:Identity Profile</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> status</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-11</td><td> bd_addr</td><td> address</td><td> Bluetooth address of remote device in little endian format</td></tr><tr><td>12-13</td><td> uint16</td><td> source</td><td> The authority who has issued the Vendor ID. Values:<ul><li><b>1: </b>Bluetooth SIG</li><li><b>0x0002: </b>USB IF</li></ul></td></tr><tr><td>14-15</td><td> uint16</td><td> vendor</td><td> Vendor ID. A comprehensive list of Bluetooth SIG -assigned ID's is at https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers</td></tr><tr><td>16-17</td><td> uint16</td><td> product</td><td> Product ID</td></tr><tr><td>18-19</td><td> uint16</td><td> version</td><td> Version ID</td></tr><tr><td>20</td><td> uint8array</td><td> description</td><td> Service Description</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event identity_remote_identity(status, address, source, vendor, product, version, description_len, description_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_identity_remote_identity_id<br><br>/* event structure*/<br>struct dumo_msg_identity_remote_identity_evt_t<br>{<br>&nbsp;&nbsp;uint16 status,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;uint16 source,<br>&nbsp;&nbsp;uint16 vendor,<br>&nbsp;&nbsp;uint16 product,<br>&nbsp;&nbsp;uint16 version,<br>&nbsp;&nbsp;uint8array description<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_le_connection"><header>Connection management for Bluetooth Low Energy (le_connection)</header>The commands and events in this class are related to managing connection establishment, parameter setting, and disconnection procedures.<div class="msg_type"><header>le_connection commands</header><div class="command" id="cmd_le_connection_list"><header >le_connection_list</header><div><p>This command can be used to list all LE connections and check their parameters.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_connection_list()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_connection_list();<br><br>/* Response id */<br>dumo_rsp_le_connection_list_id<br><br>/* Response structure */<br>struct dumo_msg_le_connection_list_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_le_connection_parameters">le_connection_parameters</a></td></tr><tr><td><a href="#evt_le_connection_list_complete">le_connection_list_complete</a></td></tr></table></div></div><div class="command" id="cmd_le_connection_set_parameters"><header >le_connection_set_parameters</header><div><p>This command can be used to request a change in the connection parameters of a Bluetooth LE connection.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection Handle</td></tr><tr><td>5-6</td><td> uint16</td><td> min_interval</td><td> Minimum value for the connection event interval. This must be set be less than or equal to max_interval.<ul><li>Time = Value x 1.25 ms</li><li>Range: 0x0006 to 0x0c80</li><li>Time Range: 7.5 ms to 4 s</li></ul>
                </td></tr><tr><td>7-8</td><td> uint16</td><td> max_interval</td><td> Maximum value for the connection event interval. This must be set greater than or equal to min_interval.<ul><li>Time = Value x 1.25 ms</li><li>Range: 0x0006 to 0x0c80</li><li>Time Range: 7.5 ms to 4 s</li></ul>
                </td></tr><tr><td>9-10</td><td> uint16</td><td> latency</td><td> Slave latency. This parameter defines how many connection intervals the slave can skip if it has no data to send<ul><li>Range: 0x0000 to 0x01f4</li></ul>Use 0x0000 for default value
                </td></tr><tr><td>11-12</td><td> uint16</td><td> timeout</td><td> Supervision timeout. The supervision timeout defines for how long the connection is maintained despite the devices being unable to communicate at the currently configured  connection intervals.<ul><li>Range: 0x000a to 0x0c80</li><li>Time = Value x 10 ms</li><li>Time Range: 100 ms to 32 s</li><li>The minimum value must be at least maximum interval in ms * (latency + 1) * 2</li></ul>It is recommended that the supervision timeout is set at a value which allows communication attempts over at least a few connection intervals.
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_connection_set_parameters(connection, min_interval, max_interval, latency, timeout)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_connection_set_parameters(uint8 connection, uint16 min_interval, uint16 max_interval, uint16 latency, uint16 timeout);<br><br>/* Response id */<br>dumo_rsp_le_connection_set_parameters_id<br><br>/* Response structure */<br>struct dumo_msg_le_connection_set_parameters_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>le_connection events</header><div class="event" id="evt_le_connection_opened"><header >le_connection_opened</header><div><p>This event indicates that a new connection was opened, whether the devices are already bonded, and what is the role of the Bluetooth module (Slave or Master). An open connection can be closed with the command endpoint_close by giving the connection handle ID obtained from this event.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x0a </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Remote device address</td></tr><tr><td>10</td><td> uint8</td><td> <a href="#enum_le_gap_address_type">address_type</a></td><td> Remote device address type</td></tr><tr><td>11</td><td> uint8</td><td> master</td><td> Module role in connection. Values:<ul><li><b>0: </b>Slave</li><li><b>1: </b>Master</li></ul></td></tr><tr><td>12</td><td> uint8</td><td> connection</td><td> Handle for new connection</td></tr><tr><td>13</td><td> uint8</td><td> bonding</td><td> Bonding handle. Values:<ul><li><b>0xff: </b>No bonding</li><li><b>Other: </b>Bonding handle</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_connection_opened(address, address_type, master, connection, bonding)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_connection_opened_id<br><br>/* event structure*/<br>struct dumo_msg_le_connection_opened_evt_t<br>{<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;<a href="#enum_le_gap_address_type">uint8 address_type</a>,<br>&nbsp;&nbsp;uint8 master,<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint8 bonding<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_le_connection_closed"><header >le_connection_closed</header><div><p>This event indicates that a connection was closed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> reason</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> connection</td><td> Handle of the closed connection</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_connection_closed(reason, connection)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_connection_closed_id<br><br>/* event structure*/<br>struct dumo_msg_le_connection_closed_evt_t<br>{<br>&nbsp;&nbsp;uint16 reason,<br>&nbsp;&nbsp;uint8 connection<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_le_connection_parameters"><header >le_connection_parameters</header><div><p>This event is triggered whenever the connection parameters are changed and at any time a connection is established. The event is also generated by LE connection listing.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x0e </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> interval</td><td> Connection interval</td></tr><tr><td>7-8</td><td> uint16</td><td> latency</td><td> Slave latency</td></tr><tr><td>9-10</td><td> uint16</td><td> timeout</td><td> Supervision timeout</td></tr><tr><td>11</td><td> uint8</td><td> <a href="#enum_le_connection_security">security_mode</a></td><td> Connection security mode</td></tr><tr><td>12-17</td><td> bd_addr</td><td> address</td><td> Remote device address</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_connection_parameters(connection, interval, latency, timeout, security_mode, address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_connection_parameters_id<br><br>/* event structure*/<br>struct dumo_msg_le_connection_parameters_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 interval,<br>&nbsp;&nbsp;uint16 latency,<br>&nbsp;&nbsp;uint16 timeout,<br>&nbsp;&nbsp;<a href="#enum_le_connection_security">uint8 security_mode</a>,<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_le_connection_list_complete"><header >le_connection_list_complete</header><div><p>This event indicates that all connections have been listed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x08 </td><td>class</td><td>Message class:Connection management for Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_connection_list_complete()</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_connection_list_complete_id<br><br>/* event structure*/<br>struct dumo_msg_le_connection_list_complete_evt_t<br>{<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>le_connection enumerations</header><div class="enum" id="enum_le_connection_security"><header>le_connection_security</header><div><p>These values indicate the Bluetooth LE Security Mode.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>le_connection_mode1_level1</td><td>No security</td></tr><tr><td>1</td><td>le_connection_mode1_level2</td><td>Unauthenticated pairing with encryption</td></tr><tr><td>2</td><td>le_connection_mode1_level3</td><td>Authenticated pairing with encryption</td></tr></table></div></div></div></div><div class="cls" id="cls_le_gap"><header>Generic Access Profile, Bluetooth Low Energy (le_gap)</header>The commands and events in this class are related to Generic Access Profile (GAP) in Bluetooth Low Energy (LE).<div class="msg_type"><header>le_gap commands</header><div class="command" id="cmd_le_gap_discover"><header >le_gap_discover</header><div><p>This command can be used to start the GAP discovery procedure to scan for advertising devices, that is to perform a device discovery. Scanning parameters 
            can be configured with the <a href="#cmd_le_gap_set_scan_parameters">le_gap_set_scan_parameters</a> command before issuing this command. To cancel an ongoing 
            discovery process use the <a href="#cmd_le_gap_end_procedure">le_gap_end_procedure</a> command.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> <a href="#enum_le_gap_discover_mode">mode</a></td><td> Bluetooth LE Discovery Mode. For values see link</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_discover(<a href="#enum_le_gap_discover_mode">mode</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_discover(<a href="#enum_le_gap_discover_mode">uint8 mode</a>);<br><br>/* Response id */<br>dumo_rsp_le_gap_discover_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_discover_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_le_gap_scan_response">le_gap_scan_response</a></td><td>Every time an advertisement packet is received, this event is triggered. The packets are not filtered in any way, so multiple events will be
                    received for every advertising device in range.</td></tr></table></div></div><div class="command" id="cmd_le_gap_end_procedure"><header >le_gap_end_procedure</header><div><p>This command can be used to end a current GAP procedure.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_end_procedure()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_end_procedure();<br><br>/* Response id */<br>dumo_rsp_le_gap_end_procedure_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_end_procedure_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_open"><header >le_gap_open</header><div><p>This command can be used to open a Bluetooth LE connection. Scanning parameters can be configured with the le_gap_set_scan_parameters command before issuing this command. To cancel on an ongoing connection process use the <a href="#cmd_endpoint_close">endpoint_close</a> command.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Address of the device to connect to</td></tr><tr><td>10</td><td> uint8</td><td> <a href="#enum_le_gap_address_type">address_type</a></td><td> Address type of the device to connect to</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> connection</td><td> Handle that will be assigned to the connection once the connection is established. This handle is valid only if the result code of this response is 0 (zero).</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_open(address, <a href="#enum_le_gap_address_type">address_type</a>)(result, connection)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_open(bd_addr *address, <a href="#enum_le_gap_address_type">uint8 address_type</a>);<br><br>/* Response id */<br>dumo_rsp_le_gap_open_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_open_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 connection<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_le_connection_opened">le_connection_opened</a></td><td>This event is triggered after the connection has been opened, and indicates whether the devices are already bonded and what is the role of the Bluetooth module (Slave or Master).</td></tr></table></div></div><div class="command" id="cmd_le_gap_set_adv_data"><header >le_gap_set_adv_data</header><div><p>This command can be used to set the data in advertisement packets or in the scan response packets. This data is used when advertising in user data mode. 
            It is recommended to set both the advertisement data and scan response data at the same time.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> scan_rsp</td><td> 
                This value selects if the data is intended for advertisement packets or scan response packets. Values: <ul><li><b>0: </b>Advertisement packets</li><li><b>1: </b>Scan response packets</li></ul>
                </td></tr><tr><td>5</td><td> uint8array</td><td> adv_data</td><td> Data to be set. Maximum length is 30 bytes</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_adv_data(scan_rsp, adv_data_len, adv_data_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_adv_data(uint8 scan_rsp, uint8 adv_data_len, const uint8 *adv_data_data);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_adv_data_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_adv_data_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_adv_parameters"><header >le_gap_set_adv_parameters</header><div><p>This command can be used to set Bluetooth LE advertisement parameters.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> interval_min</td><td> Minimum advertising interval<br>Value multiplied in units of 0.625 ms<br><br>For connectable advertising<br>Range: 0x0020 to 0x4000<br>Time range: 20 ms to 10.24 s<br><br>For non connectable advertising<br>Range: 0x00a0 to 0x4000<br>Time range: 100 ms to 10.24 s
                <br>default: 0xa0</td></tr><tr><td>6-7</td><td> uint16</td><td> interval_max</td><td> Maximum advertising  interval. 
                Value in units of 0.625 ms<ul><li>Range: 0x0020 to 0x4000</li><li>Time range: 20 ms to 10.24 s</li><li>Note: interval_max must be at least equal to or bigger than interval_min
                </li><li>default: 0x140</li></ul></td></tr><tr><td>8</td><td> uint8</td><td> channel_map</td><td> Advertisement channel map which determines which of the three channels will be used for advertising. This value is given as a bitmask. Values:<ul><li><b>1: </b>Advertise on CH37</li><li><b>2: </b>Advertise on CH38</li><li><b>3: </b>Advertise on CH37 and CH38</li><li><b>4: </b>Advertise on CH39</li><li><b>5: </b>Advertise on CH37 and CH39</li><li><b>6: </b>Advertise on CH38 and CH39</li><li><b>7: </b>Advertise on all channels</li><li>Recommended/default value: 7</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_adv_parameters(interval_min, interval_max, channel_map)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_adv_parameters(uint16 interval_min, uint16 interval_max, uint8 channel_map);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_adv_parameters_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_adv_parameters_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_conn_parameters"><header >le_gap_set_conn_parameters</header><div><p>This command can be used to set the default Bluetooth LE connection parameters. The configured values are valid for all subsequent connections that will 
            be established. For changing the parameters of an already established connection use the command <a href="#cmd_le_connection_set_parameters">le_connection_set_parameters</a>.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x08 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> min_interval</td><td> Minimum value for the connection event interval. This must be set be less than or equal to max_interval.<ul><li>Time = Value x 1.25 ms
                </li><li>Range: 0x0006 to 0x0c80</li><li>Time Range: 7.5 ms to 4 s</li><li>
                default: 100 </li></ul>
                </td></tr><tr><td>6-7</td><td> uint16</td><td> max_interval</td><td> Maximum value for the connection event interval. This must be set greater than or equal to min_interval.<ul><li>Time = Value x 1.25 ms</li><li>Range: 0x0006 to 0x0c80</li><li>Time Range: 7.5 ms to 4 s</li><li>
                default: 200 </li></ul>
                </td></tr><tr><td>8-9</td><td> uint16</td><td> latency</td><td> Slave latency. This parameter defines how many connection intervals the slave can skip if it has no data to send<ul><li>Range: 0x0000 to 0x01f4</li></ul>Use 0x0000 for default value
                </td></tr><tr><td>10-11</td><td> uint16</td><td> timeout</td><td> Supervision timeout. The supervision timeout defines for how long the connection is maintained despite the devices being unable to communicate at the currently configured  connection intervals.
                <ul><li>Range: 0x000a to 0x0c80</li>
                <li>Time = Value x 10 ms</li>
                <li>Time Range: 100 ms to 32 s</li>
                <li>The minimum value must be at least maximum interval * (latency + 1)</li>
                <li>default: 100</li>
                </ul>
                It is recommended that the supervision timeout is set at a value which allows communication attempts over at least a few connection intervals.
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_conn_parameters(min_interval, max_interval, latency, timeout)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_conn_parameters(uint16 min_interval, uint16 max_interval, uint16 latency, uint16 timeout);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_conn_parameters_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_conn_parameters_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_host_channel_classification"><header >le_gap_set_host_channel_classification</header><div><p>This command configures Bluetooth LE channel classifications. If successful, a <a href="#evt_le_gap_host_channel_classification_complete">bt_gap_host_channel_classification_complete</a> event will follow when the controller has completed the configuration.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> channel_map</td><td> Channel bitmap for 37 channels. Mark known bad channels with a zero bit, other channels with a one bit. The parameter must be given as exactly 5 bytes; the 3 high bits are ignored. </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_host_channel_classification(channel_map_len, channel_map_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_host_channel_classification(uint8 channel_map_len, const uint8 *channel_map_data);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_host_channel_classification_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_host_channel_classification_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_max_power"><header >le_gap_set_max_power</header><div><p>This command can be used to set the maximum TX power for Bluetooth LE.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> int8</td><td> max_power</td><td> Maximum radio TX power. Values: <ul><li><b>0: </b>7dBm</li><li><b>1: </b>2dBm</li><li><b>2: </b>-3dBm</li><li><b>3: </b>-8 dBm</li><li><b>4: </b>-13 dBm</li><li><b>5: </b>-18 dBm</li><li>Default value: 0</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_max_power(max_power)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_max_power(int8 max_power);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_max_power_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_max_power_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_mode"><header >le_gap_set_mode</header><div><p>This command can be used to configure the current Bluetooth LE GAP Connectable and Discoverable modes. It can be used to enable advertisements and/or allow incoming connections. To exit from this mode (to stop advertising and/or disallow incoming connections), issue this command with the Not Discoverable / Not Connectable parameter values.<br></br>Please note that to set module either discoverable or connectable can only be done when module is non-connectable and non-discoverable</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> <a href="#enum_le_gap_discoverable_mode">discover</a></td><td> Discoverable mode</td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_le_gap_connectable_mode">connect</a></td><td> Connectable mode</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_mode(<a href="#enum_le_gap_discoverable_mode">discover</a>, <a href="#enum_le_gap_connectable_mode">connect</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_mode(<a href="#enum_le_gap_discoverable_mode">uint8 discover</a>, <a href="#enum_le_gap_connectable_mode">uint8 connect</a>);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_mode_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_scan_parameters"><header >le_gap_set_scan_parameters</header><div><p>This command can be used to set Bluetooth LE scan parameters.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> scan_interval</td><td> 
                    Scanner interval. This is defined as the time interval from when the module started its last LE scan until it begins the subsequent LE scan, that is how often to scan<ul><li>Time = Value x 0.625 ms</li><li>Range: 0x0004 to 0x4000</li><li>Time Range: 2.5 ms to 10.24 s</li><li>Default: 0x0010 (10 ms)</li></ul>
                </td></tr><tr><td>6-7</td><td> uint16</td><td> scan_window</td><td> 
                    Scan window. The duration of the LE scan. scan_window shall be less than or equal to scan_interval<ul><li>Time = Value x 0.625 ms</li><li>Range: 0x0004 to 0x4000</li><li>Time Range: 2.5 ms to 10.24 s</li><li>Default: 0x0010 (10 ms)</li></ul>
                </td></tr><tr><td>8</td><td> uint8</td><td> active</td><td> 
                    Scan type indicated by a flag. Values:<ul><li><b>0: </b>Passive scanning</li><li><b>1: </b>Active scanning</li><li>Default value: 0</li><li>In passive scanning mode the module only listens to advertising packets and will not transmit any packet</li><li>In active scanning mode the module will send out a scan request packet upon receiving advertising packet from a remote device and then it will listen to the scan response packet from remote device</li></ul>
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_scan_parameters(scan_interval, scan_window, active)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_scan_parameters(uint16 scan_interval, uint16 scan_window, uint8 active);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_scan_parameters_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_scan_parameters_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_le_gap_set_scan_result_filter"><header >le_gap_set_scan_result_filter</header><div><p>
            This command can be used to filter scan responses and advertisements by device name.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> name</td><td> Beginning of the device name in the payload of the scan responses
               and advertisements must match this string for the 
               <a href="#evt_le_gap_scan_response">le_gap_scan_response</a>
               to be generated.
                To turn off filtering send length 0 array.<br><br>
                By default and at boot filtering is disabled.
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_gap_set_scan_result_filter(name_len, name_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_gap_set_scan_result_filter(uint8 name_len, const uint8 *name_data);<br><br>/* Response id */<br>dumo_rsp_le_gap_set_scan_result_filter_id<br><br>/* Response structure */<br>struct dumo_msg_le_gap_set_scan_result_filter_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>le_gap events</header><div class="event" id="evt_le_gap_scan_response"><header >le_gap_scan_response</header><div><p>This event reports any advertisement or scan response packet that is received by the module's radio while in scanning mode.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x0b </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> int8</td><td> rssi</td><td> 
                Received signal strength indicator (RSSI)<ul><li>Range: -127 to +20</li><li>Units: dBm</li></ul>
                </td></tr><tr><td>5</td><td> uint8</td><td> packet_type</td><td> 
                Advertisement packet type
                <ul>
                    <li>0x00: Connectable undirected advertising</li>
                    <li>0x02: Scannable undirected advertising</li>
                    <li>0x03: Non connectable undirected advertising</li>
                    <li>0x04: Scan Response</li>
                </ul>Note: Scan response (0x04) is only received if the device is in active scan mode.
                </td></tr><tr><td>6-11</td><td> bd_addr</td><td> address</td><td> 
                Bluetooth address of the remote device
                </td></tr><tr><td>12</td><td> uint8</td><td> address_type</td><td> 
                Advertiser address type. Values: <ul><li><b>0: </b>Public address</li><li><b>1: </b>Random address</li></ul>
                </td></tr><tr><td>13</td><td> uint8</td><td> bonding</td><td> 
                Bonding handle if the remote advertising device has previously bonded with the local device. Values:<ul><li><b>0xff: </b>No bonding</li><li><b>Other: </b>Bonding handle</li></ul>
                </td></tr><tr><td>14</td><td> uint8array</td><td> data</td><td> 
                Advertisement or scan response data
                </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_gap_scan_response(rssi, packet_type, address, address_type, bonding, data_len, data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_gap_scan_response_id<br><br>/* event structure*/<br>struct dumo_msg_le_gap_scan_response_evt_t<br>{<br>&nbsp;&nbsp;int8 rssi,<br>&nbsp;&nbsp;uint8 packet_type,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;uint8 address_type,<br>&nbsp;&nbsp;uint8 bonding,<br>&nbsp;&nbsp;uint8array data<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_le_gap_host_channel_classification_complete"><header >le_gap_host_channel_classification_complete</header><div><p>This event indicates LE host channel classification request is completed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x03 </td><td>class</td><td>Message class:Generic Access Profile, Bluetooth Low Energy</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> status</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_gap_host_channel_classification_complete(status)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_gap_host_channel_classification_complete_id<br><br>/* event structure*/<br>struct dumo_msg_le_gap_host_channel_classification_complete_evt_t<br>{<br>&nbsp;&nbsp;uint16 status<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>le_gap enumerations</header><div class="enum" id="enum_le_gap_address_type"><header>le_gap_address_type</header><div><p>These values define the Bluetooth Address types used by the stack.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>le_gap_address_type_public</td><td>LE public address</td></tr><tr><td>1</td><td>le_gap_address_type_random</td><td>LE random address</td></tr><tr><td>2</td><td>le_gap_address_type_public_identity</td><td>LE public identity address resolved by stack</td></tr><tr><td>3</td><td>le_gap_address_type_random_identity</td><td>LE random identity address resolved by stack</td></tr><tr><td>16</td><td>le_gap_address_type_bredr</td><td>Classic Bluetooth address</td></tr></table></div></div><div class="enum" id="enum_le_gap_connectable_mode"><header>le_gap_connectable_mode</header><div><p>These values define the available Connectable Modes.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>le_gap_non_connectable</td><td>Not connectable</td></tr><tr><td>1</td><td>le_gap_directed_connectable</td><td>Directed Connectable (RESERVED, DO NOT USE)</td></tr><tr><td>2</td><td>le_gap_undirected_connectable</td><td>Undirected connectable</td></tr><tr><td>3</td><td>le_gap_scannable_non_connectable</td><td>Not connectable but responds to scan_req-packets</td></tr></table></div></div><div class="enum" id="enum_le_gap_discoverable_mode"><header>le_gap_discoverable_mode</header><div><p>These values define the available Discoverable Modes, which dictate how the module is visible to other devices.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>le_gap_non_discoverable</td><td>Not discoverable</td></tr><tr><td>1</td><td>le_gap_limited_discoverable</td><td>Discoverable using both limited and general discoverable mode</td></tr><tr><td>2</td><td>le_gap_general_discoverable</td><td>Discoverable using general discoverable mode</td></tr><tr><td>3</td><td>le_gap_broadcast</td><td>Device is not discoverable in either limited or generic discoverable procedure, but may be discovered by using the Observation procedure</td></tr><tr><td>4</td><td>le_gap_user_data</td><td>Send advertisement and/or scan response data defined by the user using <a href="#cmd_le_gap_set_adv_data">le_gap_set_adv_data command</a>. 
                The limited/general discoverable flags are defined by the user.</td></tr></table></div></div><div class="enum" id="enum_le_gap_discover_mode"><header>le_gap_discover_mode</header><div><p>These values indicate which Bluetooth LE discovery mode to use when scanning for advertising slaves.</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>le_gap_discover_limited</td><td>Discover only limited discoverable devices</td></tr><tr><td>1</td><td>le_gap_discover_generic</td><td>Discover limited and generic discoverable devices</td></tr><tr><td>2</td><td>le_gap_discover_observation</td><td>Discover all devices</td></tr></table></div></div></div></div><div class="cls" id="cls_le_serial"><header>LE Cable Replacement (le_serial)</header>These commands and events are related to the establishment of Bluetooth LE cable replacement connections. LE cable replacement can be used to send and receive streaming data over LE connections.
        Please note that LE Cable Replacement commands are available only in images compiled with LE Cable Replacement sdk<div class="msg_type"><header>le_serial commands</header><div class="command" id="cmd_le_serial_listen"><header >le_serial_listen</header><div><p>
              Listen for an incoming LE cable replacement connection. Creates an endpoint which will be set as active when an incoming connection completes. Note that once the cable replacement connection is closed by the remote side, the endpoint is not usable anymore; it must be cleaned up using <a href="#cmd_endpoint_close">endpoint_close</a> command and listen must be called again to handle the next incoming connection.
              Also note that a listening endpoint may be closed only when not yet connected or already disconnected by the remote. Only the side initiating the connection may close the endpoint while it is connected.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x14 </td><td>class</td><td>Message class:LE Cable Replacement</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> characteristic</td><td> Handle of the local characteristic used to transmit data</td></tr><tr><td>6</td><td> uint8</td><td> streaming_destination</td><td> 
                      Streaming destination endpoint for the connection. This should be one of the fixed endpoints.
                      If this argument is set to the invalid endpoint handle (255), endpoint streaming will not be set up. Instead, bgscript can use <a href="#cmd_endpoint_send">endpoint_send</a> command and <a href="#evt_endpoint_data">endpoint_data</a> event for sending and receiving data.
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x14 </td><td>class</td><td>Message class:LE Cable Replacement</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> 
                      Endpoint ID assigned to the LE serial connection. Valid only if the result code is zero. Endpoint will become active when connection is ready.
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_serial_listen(characteristic, streaming_destination)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_serial_listen(uint16 characteristic, uint8 streaming_destination);<br><br>/* Response id */<br>dumo_rsp_le_serial_listen_id<br><br>/* Response structure */<br>struct dumo_msg_le_serial_listen_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_le_serial_opened">le_serial_opened</a></td></tr></table></div></div><div class="command" id="cmd_le_serial_open"><header >le_serial_open</header><div><p>Open an LE cable replacement connection endpoint to a remote device. The endpoint can be closed with the <a href="#cmd_endpoint_close">endpoint_close</a> command when done.
         
         If no ACL connection to the remote device exists, one is formed before the cable replacement connection handshake. Otherwise the existing ACL connection will be used.
         
         Note that if the remote device requires encryption or authentication for communication, ACL connection security must be set up before opening the LE cable replacement connection; see <a href="#cmd_sm_increase_security">sm_increase_security</a> command</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x14 </td><td>class</td><td>Message class:LE Cable Replacement</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> 
                Bluetooth address of the remote device in little endian format. 
                </td></tr><tr><td>10</td><td> uint8</td><td> <a href="#enum_le_gap_address_type">address_type</a></td><td> Address type of the device to connect to</td></tr><tr><td>11</td><td> uint8</td><td> streaming_destination</td><td> 
                    Streaming destination for the connection endpoint. 
                    If this argument is set to the invalid endpoint handle (255), endpoint streaming will not be set up. Instead, bgscript can use <a href="#cmd_endpoint_send">endpoint_send</a> command and <a href="#evt_endpoint_data">endpoint_data</a> event for sending and receiving data.
                    </td></tr><tr><td>12</td><td> uint8array</td><td> service</td><td> 
                    UUID of the service to connect to.
                  </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x14 </td><td>class</td><td>Message class:LE Cable Replacement</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8</td><td> endpoint</td><td> 
                      Endpoint ID assigned to the LE serial connection. Valid only if the result code is zero. Endpoint will become active when connection is ready.
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call le_serial_open(address, <a href="#enum_le_gap_address_type">address_type</a>, streaming_destination, service_len, service_data)(result, endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_le_serial_open(bd_addr *address, <a href="#enum_le_gap_address_type">uint8 address_type</a>, uint8 streaming_destination, uint8 service_len, const uint8 *service_data);<br><br>/* Response id */<br>dumo_rsp_le_serial_open_id<br><br>/* Response structure */<br>struct dumo_msg_le_serial_open_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_le_serial_opened">le_serial_opened</a></td></tr></table></div></div></div><div class="msg_type"><header>le_serial events</header><div class="event" id="evt_le_serial_opened"><header >le_serial_opened</header><div><p>This event indicates the establishment of an LE cable replacement connection.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x14 </td><td>class</td><td>Message class:LE Cable Replacement</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> endpoint</td><td> 
                      Endpoint ID assigned to the connection
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event le_serial_opened(endpoint)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_le_serial_opened_id<br><br>/* event structure*/<br>struct dumo_msg_le_serial_opened_evt_t<br>{<br>&nbsp;&nbsp;uint8 endpoint<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_sm"><header>Security Manager (sm)</header>The commands and events in this class are used to manage Bluetooth security and include commands for starting and stopping encryption and commands for managing bonding operations.<div class="msg_type"><header>sm commands</header><div class="command" id="cmd_sm_configure"><header >sm_configure</header><div><p>This command can be used to configure authentication methods and I/O capabilities of the system.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> mitm_required</td><td> Require MITM flag. Values: <ul><li><b>0: </b>Allow bonding without MITM protection</li><li><b>1: </b>Require MITM protection</li></ul></td></tr><tr><td>5</td><td> uint8</td><td> <a href="#enum_sm_io_capability">io_capabilities</a></td><td> I/O Capabilities. See link</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_configure(mitm_required, <a href="#enum_sm_io_capability">io_capabilities</a>)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_configure(uint8 mitm_required, <a href="#enum_sm_io_capability">uint8 io_capabilities</a>);<br><br>/* Response id */<br>dumo_rsp_sm_configure_id<br><br>/* Response structure */<br>struct dumo_msg_sm_configure_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_delete_bonding"><header >sm_delete_bonding</header><div><p>This command can be used to delete specified bonding information from Persistent Store.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> bonding</td><td> Bonding handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_delete_bonding(bonding)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_delete_bonding(uint8 bonding);<br><br>/* Response id */<br>dumo_rsp_sm_delete_bonding_id<br><br>/* Response structure */<br>struct dumo_msg_sm_delete_bonding_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_delete_bondings"><header >sm_delete_bondings</header><div><p>This command can be used to delete all bonding information from Persistent Store.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_delete_bondings()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_delete_bondings();<br><br>/* Response id */<br>dumo_rsp_sm_delete_bondings_id<br><br>/* Response structure */<br>struct dumo_msg_sm_delete_bondings_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_enter_passkey"><header >sm_enter_passkey</header><div><p>This command can be used to enter a passkey after receiving a passkey request event.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> passkey</td><td> Passkey. Valid range: 0-999999</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_enter_passkey(connection, passkey)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_enter_passkey(uint8 connection, uint32 passkey);<br><br>/* Response id */<br>dumo_rsp_sm_enter_passkey_id<br><br>/* Response structure */<br>struct dumo_msg_sm_enter_passkey_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_enter_pin_code"><header >sm_enter_pin_code</header><div><p>This command can be used to enter a PIN code after receiving a PIN code request event.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x07 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x0d </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth address of remote device</td></tr><tr><td>10</td><td> uint8array</td><td> pin_code</td><td> PIN code as a string. Length: 1-16 characters</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x0d </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_enter_pin_code(address, pin_code_len, pin_code_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_enter_pin_code(bd_addr *address, uint8 pin_code_len, const uint8 *pin_code_data);<br><br>/* Response id */<br>dumo_rsp_sm_enter_pin_code_id<br><br>/* Response structure */<br>struct dumo_msg_sm_enter_pin_code_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_increase_security"><header >sm_increase_security</header><div><p>This command can be used to enhance the security of a Bluetooth Classic or Bluetooth LE connection to current security requirements.
            By default, connections opened by the module are not encrypted, unless the remote device requests it (most devices do). For Bluetooth LE connections,
            this command initiates encryption, as there are only two levels of security: unencrypted and encrypted. If the devices are bonded, the existing bonding
            will be used. If the devices are not bonded, a new key will be created; if bonding is enabled the key will be stored for future use, if not the key will
            be discarded after the connection is closed. For Bluetooth Classic connections, in some cases it's possible to first increase the security to encryption 
            with a Just Works key, then increase it again by creating a MITM protected key.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_increase_security(connection)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_increase_security(uint8 connection);<br><br>/* Response id */<br>dumo_rsp_sm_increase_security_id<br><br>/* Response structure */<br>struct dumo_msg_sm_increase_security_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_list_all_bondings"><header >sm_list_all_bondings</header><div><p>This command can be used to list all bondings stored in the bonding database. Bondings are reported by using the <a href="#evt_sm_list_bonding_entry">
            sm_list_bonding_entry</a> event for each bonding and the report is ended with <a href="#evt_sm_list_all_bondings_complete">sm_list_all_bondings_complete</a> event. 
            Recommended to be used only for debugging purposes, because reading from the Persistent Store is relatively slow.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x0b </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_list_all_bondings()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_list_all_bondings();<br><br>/* Response id */<br>dumo_rsp_sm_list_all_bondings_id<br><br>/* Response structure */<br>struct dumo_msg_sm_list_all_bondings_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_sm_list_bonding_entry">sm_list_bonding_entry</a></td></tr><tr><td><a href="#evt_sm_list_all_bondings_complete">sm_list_all_bondings_complete</a></td></tr></table></div></div><div class="command" id="cmd_sm_passkey_confirm"><header >sm_passkey_confirm</header><div><p>This command can be used for accepting or rejecting reported confirm value.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5</td><td> uint8</td><td> confirm</td><td> Accept confirm value. Values:<ul><li><b>0: </b>Reject</li><li><b>1: </b>Accept confirm value</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_passkey_confirm(connection, confirm)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_passkey_confirm(uint8 connection, uint8 confirm);<br><br>/* Response id */<br>dumo_rsp_sm_passkey_confirm_id<br><br>/* Response structure */<br>struct dumo_msg_sm_passkey_confirm_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_read_bonding"><header >sm_read_bonding</header><div><p>This command can be used to read the encryption key for a specific bonding. Used in debugging for reading encryption keys which can be used 
            e.g. for protocol sniffing.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> bonding</td><td> Bonding index of bonding data</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x0a </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6-11</td><td> bd_addr</td><td> address</td><td> Bluetooth address of the remote device this bonding entry refers to</td></tr><tr><td>12</td><td> uint8</td><td> <a href="#enum_le_gap_address_type">address_type</a></td><td> Address type of the this bonding entry</td></tr><tr><td>13</td><td> uint8array</td><td> bonding_key</td><td> Encryption key stored for this bonding entry. Maximum 16 bytes</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_read_bonding(bonding)(result, address, <a href="#enum_le_gap_address_type">address_type</a>, bonding_key_len, bonding_key_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_read_bonding(uint8 bonding);<br><br>/* Response id */<br>dumo_rsp_sm_read_bonding_id<br><br>/* Response structure */<br>struct dumo_msg_sm_read_bonding_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;<a href="#enum_le_gap_address_type">uint8 address_type</a>,<br>&nbsp;&nbsp;uint8array bonding_key<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_read_bonding_configuration"><header >sm_read_bonding_configuration</header><div><p>This command can be used to read the maximum number of allowed bonding entries and to reveal the currently set bonding policy.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> max_bonding_count</td><td> Maximum allowed bonding count.
                    <br>Range: 1 to 12
                    <br>Default: 12
                    </td></tr><tr><td>5</td><td> uint8</td><td> policy_flags</td><td> Bonding policy. Values: <ul><li><b>0: </b>If database is full, new bonding attempts will fail</li><li><b>1: </b>New bonding will overwrite the oldest existing bonding</li></ul></td></tr><tr><td>6-7</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_read_bonding_configuration()(max_bonding_count, policy_flags, result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_read_bonding_configuration();<br><br>/* Response id */<br>dumo_rsp_sm_read_bonding_configuration_id<br><br>/* Response structure */<br>struct dumo_msg_sm_read_bonding_configuration_rsp_t<br>{<br>&nbsp;&nbsp;uint8 max_bonding_count,<br>&nbsp;&nbsp;uint8 policy_flags,<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_set_bondable_mode"><header >sm_set_bondable_mode</header><div><p>This command can be used to set whether the device accepts new bondings or not.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> bondable</td><td> Bondable mode. Values: <ul><li><b>0: </b>New bondings not accepted</li><li><b>1: </b>Bondings allowed</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_set_bondable_mode(bondable)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_set_bondable_mode(uint8 bondable);<br><br>/* Response id */<br>dumo_rsp_sm_set_bondable_mode_id<br><br>/* Response structure */<br>struct dumo_msg_sm_set_bondable_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_set_oob_data"><header >sm_set_oob_data</header><div><p>
                This command can be used to set the OOB data (out-of-band encryption data) for a device. The OOB data may be, for example, a PIN code exchanged over 
                an alternate path like NFC. The device will not allow any other kind of bonding if OOB data is set.
                <br><br>
                This bonding method is available only for LE bonding.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> oob_data</td><td> LE OOB data. To set OOB data, send a 16-byte array. 
                To clear OOB data, send a zero-length array.
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_set_oob_data(oob_data_len, oob_data_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_set_oob_data(uint8 oob_data_len, const uint8 *oob_data_data);<br><br>/* Response id */<br>dumo_rsp_sm_set_oob_data_id<br><br>/* Response structure */<br>struct dumo_msg_sm_set_oob_data_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_sm_store_bonding_configuration"><header >sm_store_bonding_configuration</header><div><p>This command can be used to set maximum allowed bonding count and bonding policy.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> max_bonding_count</td><td> Maximum allowed bonding count.
                    <br>Range: 1 to 12
                    <br>Default: 12
                    </td></tr><tr><td>5</td><td> uint8</td><td> policy_flags</td><td> Bonding policy. Values:
                     <ul><li><b>0: </b>If database is full, new bonding attempts will fail</li>
                     <li><b>1: </b>New bonding will overwrite the oldest existing bonding</li></ul>
                     <br>Default: 0                    
                     </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call sm_store_bonding_configuration(max_bonding_count, policy_flags)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_sm_store_bonding_configuration(uint8 max_bonding_count, uint8 policy_flags);<br><br>/* Response id */<br>dumo_rsp_sm_store_bonding_configuration_id<br><br>/* Response structure */<br>struct dumo_msg_sm_store_bonding_configuration_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>sm events</header><div class="event" id="evt_sm_passkey_display"><header >sm_passkey_display</header><div><p>This event indicates a request to display the passkey to the user.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> passkey</td><td> Passkey. Range: 0 to 999999. <ul><li>NOTE! When displaying the passkey to the user, prefix the number with 
                zeros in order to obtain a 6 digit number</li><li>Example: Passkey value is 42</li><li>Number to display to user is 000042</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_passkey_display(connection, passkey)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_passkey_display_id<br><br>/* event structure*/<br>struct dumo_msg_sm_passkey_display_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint32 passkey<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_passkey_request"><header >sm_passkey_request</header><div><p>This event indicates a request for the user to enter the passkey displayed on the remote device. Use the command <a href="#cmd_sm_enter_passkey">
            sm_enter_passkey</a> to input the passkey value.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_passkey_request(connection)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_passkey_request_id<br><br>/* event structure*/<br>struct dumo_msg_sm_passkey_request_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_confirm_passkey"><header >sm_confirm_passkey</header><div><p>This event indicates a request to display the passkey to the user and for the user to confirm the displayed passkey. 
            Use the command <a href="#cmd_sm_passkey_confirm">sm_passkey_confirm</a> to accept or reject the displayed passkey.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x05 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-8</td><td> uint32</td><td> passkey</td><td> Passkey. Range: 0 to 999999. <ul><li>NOTE! When displaying the passkey to the user, prefix the number with 
                zeros in order to obtain a 6 digit number</li><li>Example: Passkey value is 42</li><li>Number to display to user is 000042</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_confirm_passkey(connection, passkey)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_confirm_passkey_id<br><br>/* event structure*/<br>struct dumo_msg_sm_confirm_passkey_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint32 passkey<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_bonded"><header >sm_bonded</header><div><p>This event is triggered after the pairing or bonding procedure has been successfully completed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5</td><td> uint8</td><td> bonding</td><td> Bonding handle. Values: <ul><li><b>0xff: </b>Pairing completed without bonding - the pairing key will be
                discarded after disconnection.</li><li>
                <b>Other: </b>Procedure completed, pairing key stored with given bonding handle</li></ul></td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_bonded(connection, bonding)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_bonded_id<br><br>/* event structure*/<br>struct dumo_msg_sm_bonded_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint8 bonding<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_bonding_failed"><header >sm_bonding_failed</header><div><p>This event is triggered if the pairing or bonding procedure has failed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x04 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> connection</td><td> Connection handle</td></tr><tr><td>5-6</td><td> uint16</td><td> reason</td><td> Describes error that occurred</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_bonding_failed(connection, reason)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_bonding_failed_id<br><br>/* event structure*/<br>struct dumo_msg_sm_bonding_failed_evt_t<br>{<br>&nbsp;&nbsp;uint8 connection,<br>&nbsp;&nbsp;uint16 reason<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_list_bonding_entry"><header >sm_list_bonding_entry</header><div><p>This event is triggered by the command <a href="#cmd_sm_list_all_bondings">sm_list_all_bondings</a> if bondings exist in the local database.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x08 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> bonding</td><td> Bonding index of bonding data</td></tr><tr><td>5-10</td><td> bd_addr</td><td> address</td><td> Bluetooth address of the remote device</td></tr><tr><td>11</td><td> uint8</td><td> <a href="#enum_le_gap_address_type">address_type</a></td><td> Address type</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_list_bonding_entry(bonding, address, address_type)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_list_bonding_entry_id<br><br>/* event structure*/<br>struct dumo_msg_sm_list_bonding_entry_evt_t<br>{<br>&nbsp;&nbsp;uint8 bonding,<br>&nbsp;&nbsp;bd_addr address,<br>&nbsp;&nbsp;<a href="#enum_le_gap_address_type">uint8 address_type</a><br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_list_all_bondings_complete"><header >sm_list_all_bondings_complete</header><div><p>This event is triggered by the <a href="#cmd_sm_list_all_bondings">sm_list_all_bondings</a> and follows <a href="#evt_sm_list_bonding_entry">
            sm_list_bonding_entry</a> events.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_list_all_bondings_complete()</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_list_all_bondings_complete_id<br><br>/* event structure*/<br>struct dumo_msg_sm_list_all_bondings_complete_evt_t<br>{<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_sm_pin_code_request"><header >sm_pin_code_request</header><div><p>This event indicates a request for the user to enter the PIN. Use the command <a href="#cmd_sm_enter_pin_code">
            sm_enter_pin_code</a> to input the PIN code value. The PIN code is used to create legacy pairing with old (v2.0 and before) Bluetooth devices.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0f </td><td>class</td><td>Message class:Security Manager</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth address of remote device</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event sm_pin_code_request(address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_sm_pin_code_request_id<br><br>/* event structure*/<br>struct dumo_msg_sm_pin_code_request_evt_t<br>{<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>sm enumerations</header><div class="enum" id="enum_sm_io_capability"><header>sm_io_capability</header><div><p>These values define the security management related I/O capabilities supported by the module</p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>sm_io_capability_displayonly</td><td>Display Only</td></tr><tr><td>1</td><td>sm_io_capability_displayyesno</td><td>Display with Yes/No-buttons</td></tr><tr><td>2</td><td>sm_io_capability_keyboardonly</td><td>Keyboard Only</td></tr><tr><td>3</td><td>sm_io_capability_noinputnooutput</td><td>No Input and No Output</td></tr><tr><td>4</td><td>sm_io_capability_keyboarddisplay</td><td>Display with Keyboard</td></tr></table></div></div></div></div><div class="cls" id="cls_system"><header>System (system)</header>The commands and events in this class can be used to access and query the local device.
        <div class="msg_type"><header>system commands</header><div class="command" id="cmd_system_get_bt_address"><header >system_get_bt_address</header><div><p>This command can be used to read the Bluetooth address of the module.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth Classic address and LE public address in little endian format.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_get_bt_address()(address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_get_bt_address();<br><br>/* Response id */<br>dumo_rsp_system_get_bt_address_id<br><br>/* Response structure */<br>struct dumo_msg_system_get_bt_address_rsp_t<br>{<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_get_class_of_device"><header >system_get_class_of_device</header><div><p>This command can be used to read the device's Bluetooth Classic Class of Device (COD) information.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x05 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> cod</td><td> 
                        Class of Device. A comprehensive list of values can be found at https://www.bluetooth.org/en-us/specification/assigned-numbers/baseband <ul><li>Example: </li><li><b>0x001f00: </b>Uncategorized device</li></ul>
                        </td></tr><tr><td>8-9</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_get_class_of_device()(cod, result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_get_class_of_device();<br><br>/* Response id */<br>dumo_rsp_system_get_class_of_device_id<br><br>/* Response structure */<br>struct dumo_msg_system_get_class_of_device_rsp_t<br>{<br>&nbsp;&nbsp;uint32 cod,<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_get_local_name"><header >system_get_local_name</header><div><p>This command can be used to read the Bluetooth Classic friendly name of the local device. Note that for Bluetooth LE the device name is stored in the GAP Service of the GATT database.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr><tr><td>6</td><td> uint8array</td><td> name</td><td> Local device's Bluetooth Classic friendly name</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_get_local_name()(result, name_len, name_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_get_local_name();<br><br>/* Response id */<br>dumo_rsp_system_get_local_name_id<br><br>/* Response structure */<br>struct dumo_msg_system_get_local_name_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint8array name<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_hello"><header >system_hello</header><div><p>This command does not trigger any event but the response to the command is used to verify that communication between the host and the module is working.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_hello()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_hello();<br><br>/* Response id */<br>dumo_rsp_system_hello_id<br><br>/* Response structure */<br>struct dumo_msg_system_hello_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_reset"><header >system_reset</header><div><p>
            This command can be used to reset the system. It does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) depending on the selected boot mode.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> dfu</td><td> Boot mode:
                    <ul>
                    <li><b>0:</b> Normal reset</dd>
                    <li><b>1:</b> Boot to DFU mode</dd>
                    </ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Command does not have response</caption></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_reset(dfu)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_reset(uint8 dfu);<br><br>/* Command does not have response */<br></code></td></tr></table><table class="EVENT_TABLE"><caption>Events generated</caption><tr><th>Event</th><th>Description</th></tr><tr><td><a href="#evt_system_boot">system_boot</a></td><td>Sent after the device has booted into normal mode</td></tr><tr><td><a href="#evt_dfu_boot">dfu_boot</a></td><td>Sent after the device has booted into DFU mode</td></tr></table></div></div><div class="command" id="cmd_system_reset_factory_settings"><header >system_reset_factory_settings</header><div><p>This command can be used to reset the module and clear all settings including bonding information. It also resets the friendly name to its default value. The Apple iAP configuration and the persistent store are cleared. Note that the module's Bluetooth Classic / LE public address is preserved.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x07 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_reset_factory_settings()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_reset_factory_settings();<br><br>/* Response id */<br>dumo_rsp_system_reset_factory_settings_id<br><br>/* Response structure */<br>struct dumo_msg_system_reset_factory_settings_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_set_class_of_device"><header >system_set_class_of_device</header><div><p>This command is used to set the Bluetooth Classic Class of Device (COD) setting.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> cod</td><td> 
                        Class of Device. A comprehensive list of values can be found at https://www.bluetooth.org/en-us/specification/assigned-numbers/baseband <ul><li>Example: </li><li><b>0x001f00: </b>Uncategorized device</li></ul>
                        </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_set_class_of_device(cod)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_set_class_of_device(uint32 cod);<br><br>/* Response id */<br>dumo_rsp_system_set_class_of_device_id<br><br>/* Response structure */<br>struct dumo_msg_system_set_class_of_device_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_set_local_name"><header >system_set_local_name</header><div><p>This command can be used to set the local device's Bluetooth Classic friendly name. For Bluetooth LE the device name is stored in the GAP Service local 
            name parameter of the GATT database. If the device name attribute is not set as a constant in the project's GATT configuration XML file, it can be changed with 
            <a href="#cmd_gatt_server_write_attribute_value">gatt_server_write_attribute_value</a>. It is also possible to advertise with a different device name by using
            <a href="#cmd_le_gap_set_adv_data">le_gap_set_adv_data</a>, but in that case if a remote device connects and asks for the device name over GATT, the value will be 
            different from the advertised value.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> name</td><td> Local device's Bluetooth Classic friendly name. Maximum name length is 30 bytes</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_set_local_name(name_len, name_data)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_set_local_name(uint8 name_len, const uint8 *name_data);<br><br>/* Response id */<br>dumo_rsp_system_set_local_name_id<br><br>/* Response structure */<br>struct dumo_msg_system_set_local_name_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_system_set_max_power_mode"><header >system_set_max_power_mode</header><div><p>
            This command can be used to set the most efficient power saving state allowed for the system.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> power_mode</td><td> 
                Power saving mode. Values: <ul><li><b>1: </b>CPU allowed to enter idle mode</li><li><b>2: </b>CPU allowed to enter idle and sleep modes</li></ul>Default: 2. See the module data sheet for details concerning power modes.
                <br><br>Power saving modes 1 and 2 differ only if sleep has been enabled in the HW configuration. This setting is not persistent
        </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call system_set_max_power_mode(power_mode)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_system_set_max_power_mode(uint8 power_mode);<br><br>/* Response id */<br>dumo_rsp_system_set_max_power_mode_id<br><br>/* Response structure */<br>struct dumo_msg_system_set_max_power_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>system events</header><div class="event" id="evt_system_boot"><header >system_boot</header><div><p>This event indicates the device has started and is ready to receive commands that are not related to Bluetooth. When the Bluetooth stack is ready, 
            the event <a href="#evt_system_initialized">system_initialized</a> is generated. This event carries the firmware build number and other SW and HW identification codes.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x0c </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> major</td><td> Major release version</td></tr><tr><td>6-7</td><td> uint16</td><td> minor</td><td> Minor release version</td></tr><tr><td>8-9</td><td> uint16</td><td> patch</td><td> Patch release number</td></tr><tr><td>10-11</td><td> uint16</td><td> build</td><td> Build number</td></tr><tr><td>12-13</td><td> uint16</td><td> bootloader</td><td> Bootloader version</td></tr><tr><td>14-15</td><td> uint16</td><td> hw</td><td> Hardware type</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event system_boot(major, minor, patch, build, bootloader, hw)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_system_boot_id<br><br>/* event structure*/<br>struct dumo_msg_system_boot_evt_t<br>{<br>&nbsp;&nbsp;uint16 major,<br>&nbsp;&nbsp;uint16 minor,<br>&nbsp;&nbsp;uint16 patch,<br>&nbsp;&nbsp;uint16 build,<br>&nbsp;&nbsp;uint16 bootloader,<br>&nbsp;&nbsp;uint16 hw<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_system_initialized"><header >system_initialized</header><div><p>This event indicates that all systems including the Bluetooth stack and radio are ready for use.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x06 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-9</td><td> bd_addr</td><td> address</td><td> Bluetooth Classic address and LE public address in little endian format.</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event system_initialized(address)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_system_initialized_id<br><br>/* event structure*/<br>struct dumo_msg_system_initialized_evt_t<br>{<br>&nbsp;&nbsp;bd_addr address<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_system_recovery"><header >system_recovery</header><div><p>This event indicates the device has encountered an error condition and has reset.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x09 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> uint32</td><td> id1</td><td> </td></tr><tr><td>8-11</td><td> uint32</td><td> id2</td><td> </td></tr><tr><td>12</td><td> uint8array</td><td> data</td><td> </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event system_recovery(id1, id2, data_len, data_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_system_recovery_id<br><br>/* event structure*/<br>struct dumo_msg_system_recovery_evt_t<br>{<br>&nbsp;&nbsp;uint32 id1,<br>&nbsp;&nbsp;uint32 id2,<br>&nbsp;&nbsp;uint8array data<br>}<br></code></td></tr></table></div></div><div class="event" id="evt_system_script_stopped"><header >system_script_stopped</header><div><p>This event is generated when a event handler has been running more than 1 000 000 script intepreter steps (about 2 seconds). </p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x01 </td><td>class</td><td>Message class:System</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> event_class</td><td> Id to to Class of handled event
                    </td></tr><tr><td>5</td><td> uint8</td><td> event_id</td><td> event id of handled event
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event system_script_stopped(event_class, event_id)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_system_script_stopped_id<br><br>/* event structure*/<br>struct dumo_msg_system_script_stopped_evt_t<br>{<br>&nbsp;&nbsp;uint8 event_class,<br>&nbsp;&nbsp;uint8 event_id<br>}<br></code></td></tr></table></div></div></div></div><div class="cls" id="cls_test"><header>Testing commands (test)</header>The commands and events in this class can be used in production and RF development testing and as an aid in debugging.<div class="msg_type"><header>test commands</header><div class="command" id="cmd_test_device_under_test_mode"><header >test_device_under_test_mode</header><div><p>This command can used to set BT121 in "BT RF SIG mode" which is meant for 
            connecting with a Bluetooth tester where the BT121 is controlled over the LMP 
            (Link Management Protocol). See Bluetooth Core Specification 4.1 Volume 2 Part E, chapter 7.6.3
           </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x08 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_device_under_test_mode()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_device_under_test_mode();<br><br>/* Response id */<br>dumo_rsp_test_device_under_test_mode_id<br><br>/* Response structure */<br>struct dumo_msg_test_device_under_test_mode_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_dtm_end"><header >test_dtm_end</header><div><p>This command can be used to end the Bluetooth LE DTM (Direct Test Mode) mode.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x02 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> Command result</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_dtm_end()(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_dtm_end();<br><br>/* Response id */<br>dumo_rsp_test_dtm_end_id<br><br>/* Response structure */<br>struct dumo_msg_test_dtm_end_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_dtm_rx"><header >test_dtm_rx</header><div><p>This command can be used to start the Bluetooth LE DTM (Direct Test Mode) RX test.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> channel</td><td> Bluetooth channel to use in testing. Value range: 0-39</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> Command result</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_dtm_rx(channel)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_dtm_rx(uint8 channel);<br><br>/* Response id */<br>dumo_rsp_test_dtm_rx_id<br><br>/* Response structure */<br>struct dumo_msg_test_dtm_rx_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_dtm_tx"><header >test_dtm_tx</header><div><p>This command can be used to start the Bluetooth LE Direct Test Mode TX test.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> <a href="#enum_test_packet_type">packet_type</a></td><td> Packet type to use in testing value 3 corresponds to unmodulated carrier. Value range: 0-3</td></tr><tr><td>5</td><td> uint8</td><td> length</td><td> Packet length to use in testing. Value range: 0-63</td></tr><tr><td>6</td><td> uint8</td><td> channel</td><td> Bluetooth channel to use in testing. Value range: 0-39</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> Command result</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_dtm_tx(<a href="#enum_test_packet_type">packet_type</a>, length, channel)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_dtm_tx(<a href="#enum_test_packet_type">uint8 packet_type</a>, uint8 length, uint8 channel);<br><br>/* Response id */<br>dumo_rsp_test_dtm_tx_id<br><br>/* Response structure */<br>struct dumo_msg_test_dtm_tx_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_packet_test"><header >test_packet_test</header><div><p>This command can be used to start the packet mode testing.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x08 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> mode</td><td> Values:<ul><li><b>0: </b>Frequency hopping enabled</li><li><b>3: </b>Single frequency</li></ul></td></tr><tr><td>5</td><td> uint8</td><td> tx_freq</td><td> 
                Bluetooth TX channel/frequency to use in single frequency mode. Value range is 0-78, where<ul><li>
                F = 2402 + 2k, when k from 0 to 39</li><li>
                F = 2403 +2(k-40) when k from 40 to 78</li></ul>
                </td></tr><tr><td>6</td><td> uint8</td><td> rx_freq</td><td> 
                Bluetooth RX channel/frequency to use in single frequency mode. Value range is 0-78, where<ul><li>
                F = 2402 + 2k, when k from 0 to 39</li><li>
                F = 2403 +2(k-40) when k from 40 to 78</li></ul>
                </td></tr><tr><td>7</td><td> uint8</td><td> acl_type</td><td> See http://processors.wiki.ti.com/index.php/CC256x_VS_HCI_Commands#HCI_VS_DRPb_Tester_Packet_TX_RX_.280xFD85.29 for 
                values and their meaning</td></tr><tr><td>8-9</td><td> uint16</td><td> acl_len</td><td> See http://processors.wiki.ti.com/index.php/CC256x_VS_HCI_Commands#HCI_VS_DRPb_Tester_Packet_TX_RX_.280xFD85.29 for
                values and their meaning</td></tr><tr><td>10</td><td> uint8</td><td> power</td><td> TX power. Value range: 8-15, 8 is lowest, 15 is highest. See 
                http://processors.wiki.ti.com/index.php/CC256x_VS_HCI_Commands#HCI_VS_DRPb_Set_Power_Vector_.280xFD82.29 for actual dBm values.</td></tr><tr><td>11</td><td> uint8</td><td> disable_whitening</td><td> 0 to enable whitening, 1 to disable whitening</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x0a </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_packet_test(mode, tx_freq, rx_freq, acl_type, acl_len, power, disable_whitening)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_packet_test(uint8 mode, uint8 tx_freq, uint8 rx_freq, uint8 acl_type, uint16 acl_len, uint8 power, uint8 disable_whitening);<br><br>/* Response id */<br>dumo_rsp_test_packet_test_id<br><br>/* Response structure */<br>struct dumo_msg_test_packet_test_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_rx_test"><header >test_rx_test</header><div><p>This command can be used to start the RX test mode with continuous reception.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> channel</td><td> 
                Bluetooth RX channel/frequency to use. Value range is 0-78, where<ul><li>
                F = 2402 + 2k, when k from 0 to 39</li><li>
                F = 2403 +2(k-40) when k from 40 to 78</li></ul>
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x09 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_rx_test(channel)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_rx_test(uint8 channel);<br><br>/* Response id */<br>dumo_rsp_test_rx_test_id<br><br>/* Response structure */<br>struct dumo_msg_test_rx_test_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_ssp_debug"><header >test_ssp_debug</header><div><p>This command can be used to enable or disable using a pre-defined Diffie-Hellman key pair for generating Bluetooth Classic Secure Simple Pairing
            link keys. When the debug mode is enabled, a Bluetooth sniffer can decrypt the communication between two Bluetooth devices using Secure Simple Pairing. It is 
            sufficient that one party uses the debug mode - it is not necessary for both parties to use it.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> enable</td><td> Debug enable flag. Values:<ul><li><b>0: </b>Disable</li><li><b>1: </b>Enable</li></ul></td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x00 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x06 </td><td>method</td><td>Message ID</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_ssp_debug(enable)()</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_ssp_debug(uint8 enable);<br><br>/* Response id */<br>dumo_rsp_test_ssp_debug_id<br><br>/* Response structure */<br>struct dumo_msg_test_ssp_debug_rsp_t<br>{<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_test_tx_test"><header >test_tx_test</header><div><p>This command can be used to start a continuous transmission TX test. For Continuous Wave modulation, the data is all zeros, for all other modulations
            the data is PN15 pseudo-random noise.</p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x03 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8</td><td> modulation</td><td> 
                Modulation type. Values:
                <ul><li><b>0: </b>Continuous Wave</li><li>
                <b>1: </b>1 Mbit GFSK</li><li>
                <b>2: </b>2 Mbit Pi/4-DQPSK</li><li>
                <b>3: </b>3 Mbit 8-PSK</li><li>
                <b>4: </b>1 Mbit GFSK (Bluetooth LE)</li></ul></td></tr><tr><td>5</td><td> uint8</td><td> channel</td><td> 
                Bluetooth channel/frequency to use in testing.
                For modulation types 0-3, the value range is 0-78, where<ul><li>
                F = 2402 + 2k, when k from 0 to 39</li><li>
                F = 2403 +2(k-40) when k from 40 to 78</li></ul>
                For modulation type 4, the range is 0-39.
                </td></tr><tr><td>6</td><td> uint8</td><td> power</td><td> 
                TX power level. Range: 1, 8-15, where:<ul><li>
                <b>0: </b>Reserved</li><li>
                <b>1: </b>Bluetooth LE TX power (used when modulation is 4)</li><li>
                <b>2-7: </b>Reserved</li><li>
                <b>8-15: </b>Bluetooth Classic TX power, 8 is lowest, 15 is highest</li></ul>
                For the actual transmit power levels in dBm, see http://processors.wiki.ti.com/index.php/CC256x_VS_HCI_Commands#HCI_VS_DRPb_Set_Power_Vector_.280xFD82.29
                </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x02 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x03 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> 
                    Result code
                    <ul>
                    <li><b>0:</b> success</li>
                    <li><b>Non-zero:</b> an error occurred</li>
                    </ul>
                    For other values refer to the <a href="#error_codes">Error codes</a>
            </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call test_tx_test(modulation, channel, power)(result)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_test_tx_test(uint8 modulation, uint8 channel, uint8 power);<br><br>/* Response id */<br>dumo_rsp_test_tx_test_id<br><br>/* Response structure */<br>struct dumo_msg_test_tx_test_rsp_t<br>{<br>&nbsp;&nbsp;uint16 result<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>test events</header><div class="event" id="evt_test_dtm_completed"><header >test_dtm_completed</header><div><p>This event indicates that a Bluetooth LE DTM (Direct Test Mode) command has completed.</p><table class="MESSAGE_TABLE"><caption>Event</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0xa0 </td><td>hilen</td><td>Message type: Event</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x0e </td><td>class</td><td>Message class:Testing commands</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-5</td><td> uint16</td><td> result</td><td> Command result</td></tr><tr><td>6-7</td><td> uint16</td><td> number_of_packets</td><td> Number of packets received, only valid for <a href="#cmd_test_dtm_end">test_dtm_end</a> command</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript event</caption><tr><td><code>event test_dtm_completed(result, number_of_packets)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* event id*/<br>dumo_evt_test_dtm_completed_id<br><br>/* event structure*/<br>struct dumo_msg_test_dtm_completed_evt_t<br>{<br>&nbsp;&nbsp;uint16 result,<br>&nbsp;&nbsp;uint16 number_of_packets<br>}<br></code></td></tr></table></div></div></div><div class="msg_type"><header>test enumerations</header><div class="enum" id="enum_test_packet_type"><header>test_packet_type</header><div><p>
            The following table lists supported test packet types.
            </p><table class="ENUM_TABLE"><caption>Enumerations</caption><tr><th>Value</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>test_pkt_prbs9</td><td>PRBS9 packet payload</td></tr><tr><td>1</td><td>test_pkt_11110000</td><td>11110000 packet payload</td></tr><tr><td>2</td><td>test_pkt_10101010</td><td>10101010 packet payload</td></tr></table></div></div></div></div><div class="cls" id="cls_util"><header>Utilities for BGScript (util)</header>The commands and events in this class can be used to simplify BGScript based application development and are typically not used in any other applications. <div class="msg_type"><header>util commands</header><div class="command" id="cmd_util_atoi"><header >util_atoi</header><div><p>
            Converts decimal value in ASCII string to 32-bit signed integer.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x11 </td><td>class</td><td>Message class:Utilities for BGScript</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> string</td><td> 
                    String to convert
                    </td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x11 </td><td>class</td><td>Message class:Utilities for BGScript</td></tr><tr><td>3</td><td>0x00 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> int32</td><td> value</td><td> Conversion result presenting the decimal value input as a string as a 32-bit signed integer value</td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call util_atoi(string_len, string_data)(value)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_util_atoi(uint8 string_len, const uint8 *string_data);<br><br>/* Response id */<br>dumo_rsp_util_atoi_id<br><br>/* Response structure */<br>struct dumo_msg_util_atoi_rsp_t<br>{<br>&nbsp;&nbsp;int32 value<br>}<br></code></td></tr></table></div></div><div class="command" id="cmd_util_itoa"><header >util_itoa</header><div><p>
            This command can be used to convert a 32-bit signed integer value into a decimal value represented as a string.
            </p><table class="MESSAGE_TABLE"><caption>Command</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Command</td></tr><tr><td>1</td><td>0x04 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x11 </td><td>class</td><td>Message class:Utilities for BGScript</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4-7</td><td> int32</td><td> value</td><td> 32-bit number to convert</td></tr></table><table class="MESSAGE_TABLE"><caption>Response</caption><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr><tr><td>0</td><td>0x20 </td><td>hilen</td><td>Message type: Response</td></tr><tr><td>1</td><td>0x01 </td><td>lolen</td><td>Minimum payload length</td></tr><tr><td>2</td><td>0x11 </td><td>class</td><td>Message class:Utilities for BGScript</td></tr><tr><td>3</td><td>0x01 </td><td>method</td><td>Message ID</td></tr><tr><td>4</td><td> uint8array</td><td> string</td><td> 
                    Conversion result presenting the 32-bit signed integer value input as a decimal value presented by a string
                    </td></tr></table><table class="BGSCRIPT_TABLE"><caption>BGScript API</caption><tr><td><code>call util_itoa(value)(string_len, string_data)</code></td></tr></table><table class="CCODE_TABLE"><caption>BGLIB C API</caption><tr><td><code>/* Function */<br>void dumo_cmd_util_itoa(int32 value);<br><br>/* Response id */<br>dumo_rsp_util_itoa_id<br><br>/* Response structure */<br>struct dumo_msg_util_itoa_rsp_t<br>{<br>&nbsp;&nbsp;uint8array string<br>}<br></code></td></tr></table></div></div></div></div><div class="error_type" id="error_codes"><header>Error codes</header><table class="ERROR_TABLE"><caption>Errors related to hardware</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0501</td><td>ps_store_full</td><td>PS Store is full</td></tr><tr><td>0x0502</td><td>ps_key_not_found</td><td>PS key not found</td></tr><tr><td>0x0503</td><td>i2c_ack_missing</td><td>i2c ack missing</td></tr><tr><td>0x0504</td><td>i2c_timeout</td><td>i2c timeout</td></tr><tr><td>0x0505</td><td>not_configured</td><td>Not configured</td></tr><tr><td>0x0506</td><td>ble_not_supported</td><td>Not supported</td></tr></table><table class="ERROR_TABLE"><caption>Errors related to BGAPI protocol</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0101</td><td>invalid_conn_handle</td><td>Invalid connection handle</td></tr><tr><td>0x0102</td><td>waiting_response</td><td>Waiting response</td></tr><tr><td>0x0103</td><td>gatt_connection_timeout</td><td>GATT connection timeout</td></tr><tr><td>0x0180</td><td>invalid_param</td><td>Invalid Parameter</td></tr><tr><td>0x0181</td><td>wrong_state</td><td>Device in Wrong State</td></tr><tr><td>0x0182</td><td>out_of_memory</td><td>Out Of Memory</td></tr><tr><td>0x0183</td><td>not_implemented</td><td>Feature Not Implemented</td></tr><tr><td>0x0184</td><td>invalid_command</td><td>Command Not Recognized</td></tr><tr><td>0x0185</td><td>timeout</td><td>Timeout</td></tr><tr><td>0x0186</td><td>not_connected</td><td>Not Connected</td></tr><tr><td>0x0187</td><td>flow</td><td>flow</td></tr><tr><td>0x0188</td><td>user_attribute</td><td>User Attribute</td></tr><tr><td>0x0189</td><td>invalid_license_key</td><td>Invalid License Key</td></tr><tr><td>0x018a</td><td>command_too_long</td><td>Command Too Long</td></tr><tr><td>0x018b</td><td>out_of_bonds</td><td>Out of Bonds</td></tr><tr><td>0x018c</td><td>unspecified</td><td>Unspecified error</td></tr><tr><td>0x018d</td><td>hardware</td><td>Hardware failure</td></tr><tr><td>0x018e</td><td>buffers_full</td><td>Internal buffers are full</td></tr><tr><td>0x018f</td><td>disconnected</td><td>Disconnected</td></tr><tr><td>0x0190</td><td>too_many_requests</td><td>Too many requests</td></tr><tr><td>0x0191</td><td>not_supported</td><td>Feature Not Supported</td></tr><tr><td>0x0192</td><td>server_already_in_use</td><td>Server already in use</td></tr><tr><td>0x0193</td><td>no_such_endpoint</td><td>No such endpoint</td></tr><tr><td>0x0194</td><td>invalid_endpoint</td><td>Invalid endpoint</td></tr><tr><td>0x0195</td><td>invalid_endpoint_state</td><td>Invalid endpoint state</td></tr></table><table class="ERROR_TABLE"><caption>SDP errors</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0601</td><td>record_not_found</td><td>Service Record not found</td></tr><tr><td>0x0602</td><td>record_already_exist</td><td>Service Record already exist</td></tr></table><table class="ERROR_TABLE"><caption>Errors from Security Manager Protocol</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0301</td><td>passkey_entry_failed</td><td>Passkey Entry Failed</td></tr><tr><td>0x0302</td><td>oob_not_available</td><td>OOB Data is not available</td></tr><tr><td>0x0303</td><td>authentication_requirements</td><td>Authentication Requirements</td></tr><tr><td>0x0304</td><td>confirm_value_failed</td><td>Confirm Value Failed</td></tr><tr><td>0x0305</td><td>pairing_not_supported</td><td>Pairing Not Supported</td></tr><tr><td>0x0306</td><td>encryption_key_size</td><td>Encryption Key Size</td></tr><tr><td>0x0307</td><td>command_not_supported</td><td>Command Not Supported</td></tr><tr><td>0x0308</td><td>unspecified_reason</td><td>Unspecified Reason</td></tr><tr><td>0x0309</td><td>repeated_attempts</td><td>Repeated Attempts</td></tr><tr><td>0x030a</td><td>invalid_parameters</td><td>Invalid Parameters</td></tr><tr><td>0x030b</td><td>no_bonding</td><td>No Bonding</td></tr></table><table class="ERROR_TABLE"><caption>Bluetooth errors</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0202</td><td>unknown_connection_identifier</td><td>Unknown Connection Identifier</td></tr><tr><td>0x0204</td><td>page_timeout</td><td>Page Timeout</td></tr><tr><td>0x0205</td><td>authentication_failure</td><td>Authentication Failure</td></tr><tr><td>0x0206</td><td>pin_or_key_missing</td><td>Pin or Key Missing</td></tr><tr><td>0x0207</td><td>memory_capacity_exceeded</td><td>Memory Capacity Exceeded</td></tr><tr><td>0x0208</td><td>connection_timeout</td><td>Connection Timeout</td></tr><tr><td>0x0209</td><td>connection_limit_exceeded</td><td>Connection Limit Exceeded</td></tr><tr><td>0x020a</td><td>synchronous_connectiontion_limit_exceeded</td><td>Synchronous connection limit to a device exceeded</td></tr><tr><td>0x020b</td><td>acl_connection_already_exists</td><td>ACL Connection already exists</td></tr><tr><td>0x020c</td><td>command_disallowed</td><td>Command Disallowed</td></tr><tr><td>0x020d</td><td>connection_rejected_due_to_limited_resources</td><td>Connection rejected due to limited resources</td></tr><tr><td>0x020e</td><td>connection_rejected_due_to_security_reasons</td><td>Connection rejected due to security reasons</td></tr><tr><td>0x020f</td><td>connection_rejected_due_to_unacceptable_bd_addr</td><td>Connection rejected due to unacceptable Bluetooth address</td></tr><tr><td>0x0210</td><td>connection_accept_timeout_exceeded</td><td>Connection accept timeout exceeded</td></tr><tr><td>0x0211</td><td>unsupported_feature_or_parameter_value</td><td>Unsupported feature or parameter value</td></tr><tr><td>0x0212</td><td>invalid_command_parameters</td><td>Invalid Command Parameters</td></tr><tr><td>0x0213</td><td>remote_user_terminated</td><td>Remote User Terminated Connection</td></tr><tr><td>0x0214</td><td>remote_device_terminated_connection_due_to_low_resources</td><td>Remote device terminated connection due to low resources</td></tr><tr><td>0x0215</td><td>remote_powering_off</td><td>Remote Device Terminated Connection due to Power Off</td></tr><tr><td>0x0216</td><td>connection_terminated_by_local_host</td><td>Connection Terminated by Local Host</td></tr><tr><td>0x0217</td><td>repeated_attempts</td><td>Repeated attempts</td></tr><tr><td>0x0218</td><td>pairing_not_allowed</td><td>Pairing not allowed</td></tr><tr><td>0x0219</td><td>unknown_lmp_pdu</td><td>Unknown LMP PDU</td></tr><tr><td>0x021a</td><td>unsupported_remote_feature</td><td>Unsupported remote feature / unsupported LMP feature</td></tr><tr><td>0x021b</td><td>sco_offset_rejected</td><td>SCO offset rejected</td></tr><tr><td>0x021c</td><td>sco_interval_rejected</td><td>SCO interval rejected</td></tr><tr><td>0x021d</td><td>sco_air_mode_rejected</td><td>SCO air mode rejected</td></tr><tr><td>0x021e</td><td>invalid_lmp_parameters</td><td>Invalid LMP parameters / Invalid LL parameters</td></tr><tr><td>0x021f</td><td>unspecified_error</td><td>Unspecified error</td></tr><tr><td>0x0220</td><td>unsupported_lmp_parameter_value</td><td>Unsupported LMP Parameter value / unsupported LL parameter value</td></tr><tr><td>0x0221</td><td>role_change_not_allowed</td><td>Role change not allowed</td></tr><tr><td>0x0222</td><td>ll_response_timeout</td><td>LL Response Timeout</td></tr><tr><td>0x0223</td><td>lmp_error_transaction_collision</td><td>LMP error transaction  collision</td></tr><tr><td>0x0224</td><td>lmp_pdu_not_allowed</td><td>LMP PDU not allowed</td></tr><tr><td>0x0225</td><td>encryption_mode_not_acceptable</td><td>Encryption mode not acceptable</td></tr><tr><td>0x0226</td><td>link_key_cannot_be_changed</td><td>Link key cannot be changed</td></tr><tr><td>0x0227</td><td>requested_qos_not_supported</td><td>Requested QoS not supported</td></tr><tr><td>0x0228</td><td>instant_passed</td><td>Instant passed</td></tr><tr><td>0x0229</td><td>pairing_with_unit_key_not_supported</td><td>Pairing with unit key not supported</td></tr><tr><td>0x022a</td><td>different_transaction_collision</td><td>Different transaction collision</td></tr><tr><td>0x022c</td><td>qos_unacceptable_parameter</td><td>QoS unacceptable parameter</td></tr><tr><td>0x022d</td><td>qos_rejected</td><td>QoS rejected</td></tr><tr><td>0x022e</td><td>channel_assesment_not_supported</td><td>Channel assessment not supported</td></tr><tr><td>0x022f</td><td>insufficient_security</td><td>Insufficient security</td></tr><tr><td>0x0230</td><td>parameter_out_of_mandatory_range</td><td>Parameter out of mandatory range</td></tr><tr><td>0x0232</td><td>role_switch_pending</td><td>Role switch pending</td></tr><tr><td>0x0234</td><td>reserved_slot_violation</td><td>Reserved slot violation</td></tr><tr><td>0x0235</td><td>role_switch_failed</td><td>Role switch failed</td></tr><tr><td>0x0236</td><td>extended_inquiry_response_too_large</td><td>Extended inquiry response too large</td></tr><tr><td>0x0237</td><td>simple_pairing_not_supported_by_host</td><td>Simple pairing not supported by host</td></tr><tr><td>0x0238</td><td>host_busy_pairing</td><td>Host bysy-pairing</td></tr><tr><td>0x0239</td><td>connection_rejected_due_to_no_suitable_channel_found</td><td>Connection rejected due to no suitable channel found</td></tr><tr><td>0x023a</td><td>controller_busy</td><td>Controller Busy</td></tr><tr><td>0x023b</td><td>unacceptable_connection_interval</td><td>Unacceptable Connection Interval</td></tr><tr><td>0x023c</td><td>directed_advertising_timeout</td><td>Directed Advertising Timeout</td></tr><tr><td>0x023d</td><td>connection_terminated_due_to_mic_failure</td><td>MIC Failure</td></tr><tr><td>0x023e</td><td>connection_failed_to_be_established</td><td>Connection Failed to be Established</td></tr><tr><td>0x023f</td><td>mac_connection_failed</td><td>MAC connection failed</td></tr><tr><td>0x0240</td><td>coarse_clock_adjustment_rejected_but_will_try_to_adjust_using_clock_dragging</td><td>Coarse clock adjustment rejected but will try to adjust using clock dragging</td></tr><tr><td>0x0241</td><td>refused_psm_not_supported</td><td>PSM not supported</td></tr><tr><td>0x0242</td><td>refused_security_block</td><td>Security block</td></tr><tr><td>0x0243</td><td>refused_no_resources</td><td>No resources</td></tr><tr><td>0x0244</td><td>acl_disconnected</td><td>ACL disconnected</td></tr><tr><td>0x0245</td><td>psm_already_in_use</td><td>PSM is already in use</td></tr></table><table class="ERROR_TABLE"><caption>Application errors</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0a01</td><td>file_open_failed</td><td>File open failed</td></tr><tr><td>0x0a02</td><td>xml_parse_failed</td><td>XML parse failed</td></tr><tr><td>0x0a03</td><td>device_connection_failed</td><td>Device connection failed</td></tr><tr><td>0x0a04</td><td>device_comunication_failed</td><td>Device communication failed</td></tr></table><table class="ERROR_TABLE"><caption>Errors from Attribute Protocol</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0401</td><td>invalid_handle</td><td>Invalid Handle</td></tr><tr><td>0x0402</td><td>read_not_permitted</td><td>Read Not Permitted</td></tr><tr><td>0x0403</td><td>write_not_permitted</td><td>Write Not Permitted</td></tr><tr><td>0x0404</td><td>invalid_pdu</td><td>Invalid PDU</td></tr><tr><td>0x0405</td><td>insufficient_authentication</td><td>Insufficient Authentication</td></tr><tr><td>0x0406</td><td>request_not_supported</td><td>Request Not Supported</td></tr><tr><td>0x0407</td><td>invalid_offset</td><td>Invalid Offset</td></tr><tr><td>0x0408</td><td>insufficient_authorization</td><td>Insufficient Authorization</td></tr><tr><td>0x0409</td><td>prepare_queue_full</td><td>Prepare Queue Full</td></tr><tr><td>0x040a</td><td>att_not_found</td><td>Attribute Not Found</td></tr><tr><td>0x040b</td><td>att_not_long</td><td>Attribute Not Long</td></tr><tr><td>0x040c</td><td>insufficient_enc_key_size</td><td>Insufficient Encryption Key Size</td></tr><tr><td>0x040d</td><td>invalid_att_length</td><td>Invalid Attribute Value Length</td></tr><tr><td>0x040e</td><td>unlikely_error</td><td>Unlikely Error</td></tr><tr><td>0x040f</td><td>insufficient_encryption</td><td>Insufficient Encryption</td></tr><tr><td>0x0410</td><td>unsupported_group_type</td><td>Unsupported Group Type</td></tr><tr><td>0x0411</td><td>insufficient_resources</td><td>Insufficient Resources</td></tr><tr><td>0x0480</td><td>application</td><td>Application Error Codes</td></tr></table><table class="ERROR_TABLE"><caption>Filesystem errors</caption><th>Code</th><th>Name</th><th>Description</th><tr><td>0x0901</td><td>file_not_found</td><td>File not found</td></tr></table></div>
</div><div id="sidebar"><ul><li><a href=#cls_bt_connection>bt_connection</a></li><li><a href=#cls_bt_gap>bt_gap</a></li><li><a href=#cls_bt_hid>bt_hid</a></li><li><a href=#cls_bt_rfcomm>bt_rfcomm</a></li><li><a href=#cls_bt_sdp>bt_sdp</a></li><li><a href=#cls_dfu>dfu</a></li><li><a href=#cls_endpoint>endpoint</a></li><li><a href=#cls_flash>flash</a></li><li><a href=#cls_gatt>gatt</a></li><li><a href=#cls_gatt_server>gatt_server</a></li><li><a href=#cls_hardware>hardware</a></li><li><a href=#cls_identity>identity</a></li><li><a href=#cls_le_connection>le_connection</a></li><li><a href=#cls_le_gap>le_gap</a></li><li><a href=#cls_le_serial>le_serial</a></li><li><a href=#cls_sm>sm</a></li><li><a href=#cls_system>system</a></li><li><a href=#cls_test>test</a></li><li><a href=#cls_util>util</a></li><li><a href=#error_codes>Error codes</a></li></ul></div></div></body></html>